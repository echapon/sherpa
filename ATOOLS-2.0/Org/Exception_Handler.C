#include "Exception.H"

#include "Run_Parameter.H"
#include "MyStrStream.H"
#include <sys/types.h>
#include <unistd.h>

#define USING_Stack_Trace
#ifndef __USE_GNU
#ifdef __GNUC__
#define __USE_GNU
#ifdef __ppc__
#undef USING_Stack_Trace
#endif
#else 
#undef USING_Stack_Trace
#endif
#endif

#ifdef USING_Stack_Trace
#include <execinfo.h>
#include <dlfcn.h>
#define MAX_BACKTRACE_DEPTH 128
#endif

using namespace ATOOLS;

bool Exception_Handler::s_active=true;
bool Exception_Handler::s_prepared=false;
bool Exception_Handler::s_stacktrace=true;
bool Exception_Handler::s_print=true;

unsigned int Exception_Handler::s_exitcode=0;
unsigned int Exception_Handler::s_signal=0;
Exception *Exception_Handler::s_exception=0;

unsigned int Exception_Handler::s_nbus=0;
unsigned int Exception_Handler::s_nsegv=0;

std::string Exception_Handler::s_progname="Sherpa";

std::vector<Exception_Handler::Tester_Function> 
Exception_Handler::s_testerfunctions=
  std::vector<Exception_Handler::Tester_Function>();
std::vector<Exception_Handler::Terminator_Function> 
Exception_Handler::s_terminatorfunctions=
  std::vector<Exception_Handler::Terminator_Function>();
std::vector<Tester_Object*> 
Exception_Handler::s_testerobjects=std::vector<Tester_Object*>();
std::vector<Terminator_Object*> 
Exception_Handler::s_terminatorobjects=std::vector<Terminator_Object*>();

static bool s_noremove=false;

bool Exception_Handler::ApproveTerminate()
{
  static size_t inttrials=0;
  if (++inttrials>2) kill(getpid(),9);
  if (s_print) msg_Tracking()<<"Exception_Handler::ApproveTerminate(): "
			     <<"Asking for termination ..."<<std::endl;
  if (s_testerfunctions.size()==0 && s_testerobjects.size()==0) {
    if (s_print) msg_Tracking()<<"... approved."<<std::endl;
    return true;
  }
  bool approved=true;
  s_noremove=true;
  for (size_t i=0;i<s_testerfunctions.size();++i) 
    if (!s_testerfunctions[i]()) approved=false;
  for (size_t i=0;i<s_testerobjects.size();++i) 
    if (!s_testerobjects[i]->ApproveTerminate()) approved=false;
  s_noremove=false;
  if (approved && s_print) msg_Tracking()<<"... approved."<<std::endl;
  else if (s_print) msg_Tracking()<<"... refused."<<std::endl;
  return approved;
}

void Exception_Handler::PrepareTerminate()
{
  static size_t trials=0;
  if (++trials>3) kill(getpid(),9);
  if (s_print) msg_Tracking()<<"Exception_Handler::PrepareTerminate(): "
			     <<"Preparing termination ..."<<std::endl;
  while (s_terminatorobjects.size()>0) {
    s_noremove=true;
    s_terminatorobjects.back()->PrepareTerminate();
    s_noremove=false;
    std::vector<Terminator_Object*>::iterator end=s_terminatorobjects.end();
    RemoveTerminatorObject(*--end);
  }
  while (s_terminatorfunctions.size()>0) {
    s_noremove=true;
    s_terminatorfunctions.back()();
    s_noremove=false;
    std::vector<Terminator_Function>::iterator end=s_terminatorfunctions.end();
    RemoveTerminatorFunction(*--end);
  }
  if (s_print) msg_Tracking()<<"... prepared."<<std::endl;
}

void Exception_Handler::Exit(int exitcode)
{
  if (s_print) msg.Error()<<om::bold<<"Exception_Handler::Exit: "
			  <<om::reset<<om::blue<<"Exiting "
			  <<s_progname<<" with code "
			  <<om::reset<<om::bold<<"("
			  <<om::red<<exitcode<<om::reset<<om::bold<<")"
			  <<om::reset<<tm::curon<<std::endl;
  msg.LogFile()<<"Exception_Handler::Exit: "
	       <<"Exiting Sherpa with code ("<<exitcode<<")"<<std::endl;
  exit(exitcode);
}

void Exception_Handler::Terminate() 
{
  bool modifiable=msg.Modifiable();
  msg.SetModifiable(false);
  GenerateStackTrace(msg.LogFile(),true,"! ");
  msg.SetModifiable(modifiable);
  if (s_stacktrace) GenerateStackTrace(msg.Error());
  if (!ApproveTerminate()) {
    s_exception=NULL;
    return;
  }
  PrepareTerminate();
  s_prepared=true;
  if (!s_active) abort();
  SetExitCode();
  Exit(s_exitcode);
}

void Exception_Handler::RemoveTesterObject(Tester_Object *const testerobject)
{
  if (s_noremove) return;
  for (std::vector<Tester_Object*>::iterator toit=s_testerobjects.begin();
       toit!=s_testerobjects.end();) {
    if (*toit==testerobject) toit=s_testerobjects.erase(toit); 
    else ++toit;
  }
}

void Exception_Handler::
RemoveTerminatorObject(Terminator_Object *const terminatorobject)
{
  if (s_noremove) return;
  for (std::vector<Terminator_Object*>::iterator 
	 toit=s_terminatorobjects.begin();
       toit!=s_terminatorobjects.end();) {
    if (*toit==terminatorobject) toit=s_terminatorobjects.erase(toit); 
    else ++toit;
  }
}

void Exception_Handler::RemoveTesterFunction(bool (*function)(void))
{
  if (s_noremove) return;
  for (std::vector<Tester_Function>::iterator tfit=s_testerfunctions.begin();
       tfit!=s_testerfunctions.end();) {
    if (*tfit==function) tfit=s_testerfunctions.erase(tfit); 
    else ++tfit;
  }
}

void Exception_Handler::RemoveTerminatorFunction(void (*function)(void))
{
  if (s_noremove) return;
  for (std::vector<Terminator_Function>::iterator 
	 tfit=s_terminatorfunctions.begin();
       tfit!=s_terminatorfunctions.end();) {
    if (*tfit==function) tfit=s_terminatorfunctions.erase(tfit); 
    else ++tfit;
  }
}

void Exception_Handler::SetExitCode()
{
  s_print=true;
  if (s_exception==NULL) return;
  if (s_exception->m_class=="ISR_Handler")                 s_exitcode=151;
  else if (s_exception->m_class=="MI_Base")                s_exitcode=211;
  else if (s_exception->m_class=="Simple_Chain")           s_exitcode=212;
  else if (s_exception->m_class=="Matrix_Element_Handler") s_exitcode=201;
  else s_exitcode=1;
  if (s_exception->m_type==ex::normal_exit) s_print=false;
}

void Exception_Handler::SignalHandler(int signal) 
{
  s_signal=signal;
  s_print=true;
  std::string input="y";
  msg.Error()<<std::endl<<om::bold<<"Exception_Handler::SignalHandler: "
	     <<om::reset<<om::blue<<"Signal "<<om::reset<<om::bold
	     <<"("<<om::red<<signal<<om::reset<<om::bold<<")"
	     <<om::reset<<om::blue<<" caught. "<<om::reset<<std::endl;
  switch (signal) {
  case SIGSEGV:
    ++s_nsegv;
    GenerateStackTrace(std::cout,false);
    if (!rpa.gen.BatchMode()) {
      msg.Error()<<"   Do you want to debug the program (y/n)? "<<om::reset;
      std::cin>>input;
      if (input=="y" || input=="Y") {
	system((std::string("gdb Sherpa ")+ToString(getpid())).c_str());
	kill(getpid(),9);
      }
    }
    if (s_nsegv>3) {
      msg.Error()<<om::reset<<"   Abort immediately."<<om::reset<<std::endl;
      kill(getpid(),9);
    }
  case SIGABRT:
    if (!s_active && s_prepared) abort();
  case SIGTERM:
  case SIGXCPU:
    msg.Error()<<om::reset<<"   Cannot continue."<<om::reset<<std::endl;
    s_exitcode=2;
    Terminate();
    break;
  case SIGINT:
    if (!rpa.gen.BatchMode()) {
      msg.Error()<<"   Do you want to stop the program (y/n/k/p/d/s)? "
		 <<om::reset;
      std::cin>>input;
    }
    if (input=="k" || input=="K") {
      kill(getpid(),9);
    }
    else if (input=="p" || input=="P") {
      bool print=s_print;
      s_print=true;
      PrepareTerminate();
      s_print=print;
      std::cin.get();
    }
    else if (input=="d" || input=="D") {
      system((std::string("gdb Sherpa ")+ToString(getpid())).c_str());
    }
    else if (input=="s" || input=="S") {
      GenerateStackTrace(std::cout,false);
      std::cout<<" Hit <return> to continue. ";      
      std::cin.get();
      std::cin.get();
    }
    if (input!="y" && input!="Y") return;
    s_exitcode=1;
    Terminate();
    break;
  case SIGBUS:
    ++s_nbus;
    if (s_nbus>3) {
      msg.Error()<<om::reset<<"   Abort immediately."<<om::reset<<std::endl;
      kill(getpid(),9);
    }
    GenerateStackTrace(std::cout,false);
    msg.Error()<<om::reset<<"   Cannot continue."<<om::reset<<std::endl;
    s_exitcode=3;
    Terminate();
    break;
  case SIGFPE:
    msg.Error()<<"   Sherpa does not throw floating point exceptions."
	       <<om::reset<<std::endl;
    break;
  default:
    msg.Error()<<"   Cannot handle signal."<<om::reset<<std::endl;
    s_exitcode=1;
    Terminate();
  }
}

void Exception_Handler::GenerateStackTrace(std::ostream &ostr,
					   const bool endline,
					   const std::string &comment)
{
#ifdef USING_Stack_Trace
  ostr<<comment<<om::bold<<"Exception_Handler::GenerateStackTrace(..): "
      <<om::reset<<om::blue<<"Generating stack trace "<<om::reset
      <<"(adapted from ROOT version 3.10) "<<om::bold<<"\n{"
      <<om::reset<<std::endl;
  // adapted from root version 3.10 TUnixSystem.cxx
  void *trace[MAX_BACKTRACE_DEPTH];
  int depth=backtrace(trace,MAX_BACKTRACE_DEPTH);
  for (int n=0; n<depth;++n) {
    unsigned long addr=(unsigned long)trace[n];
    Dl_info info;
    if (dladdr(trace[n],&info) && info.dli_fname && info.dli_fname[0]) {
      unsigned long symaddr=(unsigned long)info.dli_saddr;
      const char *symname=info.dli_sname;
      if (!info.dli_sname || !info.dli_sname[0]) symname="<unknown>";
      ostr<<comment<<om::bold<<"   0x"<<std::setiosflags(std::ios::left)
	  <<std::setw(8)<<std::hex<<symaddr<<std::dec<<om::reset
	  <<" in   '"<<om::red<<symname<<om::reset
	  <<"'\n                from '"<<om::brown<<info.dli_fname
	  <<om::reset<<"'"<<std::endl;
    } 
    else {
      ostr<<comment<<"   "<<addr<<" in   <unknown function>"<<std::endl;
    }
  }
  ostr<<comment<<om::bold<<"}"<<om::reset;
  if (endline) ostr<<std::endl;
#endif
}
