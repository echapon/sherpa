#include "Exception.H"

#include "Run_Parameter.H"
#include "MyStrStream.H"
#include "CXXFLAGS.H"
#include "Shell_Tools.H"
#include <sys/types.h>
#include <unistd.h>

#define USING_Stack_Trace
#ifndef __USE_GNU
#ifdef __GNUC__
#define __USE_GNU
#ifdef __ppc__
#undef USING_Stack_Trace
#endif
#else 
#undef USING_Stack_Trace
#endif
#endif

#ifdef USING_Stack_Trace
#include <execinfo.h>
#include <dlfcn.h>
#define MAX_BACKTRACE_DEPTH 128
#endif

using namespace ATOOLS;

ATOOLS::Exception_Handler *ATOOLS::exh(NULL);

Exception_Handler::Exception_Handler():
  m_active(true), m_prepared(false), m_stacktrace(true), 
  m_print(true), m_noremove(false),
  m_signal(0), m_exitcode(0), m_exception(0), m_nbus(0), m_nsegv(0),
  m_progname("Sherpa") {}

void Exception_Handler::Init()
{
  static bool init(false);
  if (!init) {
    exh = new Exception_Handler();
    init=true;
  }
}

bool Exception_Handler::ReadInStatus(const std::string &path)
{
  bool success(true);
  msg_Info()<<METHOD<<"(): Reading status from '"<<path<<"' {"<<std::endl;
  for (size_t i=0;i<m_terminatorobjects.size();++i) 
    if (!m_terminatorobjects[i]->ReadInStatus(path)) success=false;
  msg_Info()<<"}"<<std::endl;
  return success;
}

bool Exception_Handler::ApproveTerminate()
{
  static size_t inttrials=0;
  if (++inttrials>2) kill(getpid(),9);
  if (m_print) msg_Tracking()<<"Exception_Handler::ApproveTerminate(): "
			     <<"Asking for termination ..."<<std::endl;
  if (m_testerfunctions.size()==0 && m_testerobjects.size()==0) {
    if (m_print) msg_Tracking()<<"... approved."<<std::endl;
    return true;
  }
  bool approved=true;
  m_noremove=true;
  for (size_t i=0;i<m_testerfunctions.size();++i) 
    if (!m_testerfunctions[i]()) approved=false;
  for (size_t i=0;i<m_testerobjects.size();++i) 
    if (!m_testerobjects[i]->ApproveTerminate()) approved=false;
  m_noremove=false;
  if (approved && m_print) msg_Tracking()<<"... approved."<<std::endl;
  else if (m_print) msg_Tracking()<<"... refused."<<std::endl;
  return approved;
}

void Exception_Handler::PrepareTerminate()
{
  static size_t trials=0;
  if (++trials>3) kill(getpid(),9);
  if (m_print) msg_Tracking()<<"Exception_Handler::PrepareTerminate(): "
			     <<"Preparing termination ..."<<std::endl;
  while (m_terminatorobjects.size()>0) {
    m_noremove=true;
    m_terminatorobjects.back()->PrepareTerminate();
    m_noremove=false;
    std::vector<Terminator_Object*>::iterator end=m_terminatorobjects.end();
    RemoveTerminatorObject(*--end);
  }
  while (m_terminatorfunctions.size()>0) {
    m_noremove=true;
    m_terminatorfunctions.back()();
    m_noremove=false;
    std::vector<Terminator_Function>::iterator end=m_terminatorfunctions.end();
    RemoveTerminatorFunction(*--end);
  }
  if (m_print) msg_Tracking()<<"... prepared."<<std::endl;
}

void Exception_Handler::Exit(int exitcode)
{
  if (m_print) msg.Error()<<om::bold<<"Exception_Handler::Exit: "
			  <<om::reset<<om::blue<<"Exiting "
			  <<m_progname<<" with code "
			  <<om::reset<<om::bold<<"("
			  <<om::red<<exitcode<<om::reset<<om::bold<<")"
			  <<om::reset<<tm::curon<<std::endl;
  msg.LogFile()<<"Exception_Handler::Exit: "
	       <<"Exiting "<<m_progname<<" with code ("
	       <<exitcode<<")"<<std::endl;
  exit(exitcode);
}

void Exception_Handler::Reset()
{
  exh->m_exception=NULL;
  exh->m_signal=0;
}

void ATOOLS::Terminate() 
{
  exh->Terminate();
  exh->Reset();
}

void Exception_Handler::Terminate() 
{
  bool modifiable=msg.Modifiable();
  SetExitCode();
  if ((m_signal!=SIGTERM && m_signal!=SIGINT) &&
      (m_exception==NULL || m_exception->Type()!=ex::normal_exit)) {
    if (m_print) {
      msg.SetModifiable(false);
      GenerateStackTrace(msg.LogFile(),true,"! ");
      msg.SetModifiable(modifiable);
      if (m_stacktrace) GenerateStackTrace(msg.Error());
    }
    rpa.gen.SetVariable
      ("SHERPA_STATUS_PATH",rpa.gen.Variable("SHERPA_RUN_PATH")+
       "/Status__"+rpa.gen.Timer().TimeString(3));
    msg.Error()<<METHOD<<"(): Pre-crash status saved to '"
	       <<rpa.gen.Variable("SHERPA_STATUS_PATH")<<"'."<<std::endl;
    MakeDir(rpa.gen.Variable("SHERPA_STATUS_PATH"),493);
  }
  if (!ApproveTerminate()) {
    m_exception=NULL;
    return;
  }
  PrepareTerminate();
  m_prepared=true;
  if (!m_active) abort();
  Exit(m_exitcode);
}

void Exception_Handler::AddTesterFunction(bool (*function)(void))
{ 
  Init();
  exh->m_testerfunctions.push_back(function); 
}

void Exception_Handler::AddTerminatorFunction(void (*function)(void))
{ 
  Init();
  exh->m_terminatorfunctions.push_back(function); 
}

void Exception_Handler::AddTesterObject(Tester_Object *const object)
{ 
  Init();
  exh->m_testerobjects.push_back(object); 
}

void Exception_Handler::AddTerminatorObject(Terminator_Object *const object)
{ 
  Init();
  exh->m_terminatorobjects.push_back(object); 
}

void Exception_Handler::RemoveTesterObject(Tester_Object *const testerobject)
{
  if (m_noremove) return;
  for (std::vector<Tester_Object*>::iterator toit=m_testerobjects.begin();
       toit!=m_testerobjects.end();) {
    if (*toit==testerobject) toit=m_testerobjects.erase(toit); 
    else ++toit;
  }
}

void Exception_Handler::
RemoveTerminatorObject(Terminator_Object *const terminatorobject)
{
  if (m_noremove) return;
  for (std::vector<Terminator_Object*>::iterator 
	 toit=m_terminatorobjects.begin();
       toit!=m_terminatorobjects.end();) {
    if (*toit==terminatorobject) toit=m_terminatorobjects.erase(toit); 
    else ++toit;
  }
}

void Exception_Handler::RemoveTesterFunction(bool (*function)(void))
{
  if (m_noremove) return;
  for (std::vector<Tester_Function>::iterator tfit=m_testerfunctions.begin();
       tfit!=m_testerfunctions.end();) {
    if (*tfit==function) tfit=m_testerfunctions.erase(tfit); 
    else ++tfit;
  }
}

void Exception_Handler::RemoveTerminatorFunction(void (*function)(void))
{
  if (m_noremove) return;
  for (std::vector<Terminator_Function>::iterator 
	 tfit=m_terminatorfunctions.begin();
       tfit!=m_terminatorfunctions.end();) {
    if (*tfit==function) tfit=m_terminatorfunctions.erase(tfit); 
    else ++tfit;
  }
}

void Exception_Handler::SetExitCode()
{
  m_print=true;
  if (m_exception==NULL) return;
  if (m_exception->m_class=="Matrix_Element_Handler") m_exitcode=201;
  else m_exitcode=1;
  if (m_exception->m_type==ex::normal_exit) m_print=false;
}

void ATOOLS::SignalHandler(int signal) 
{
  exh->Init();
  exh->SignalHandler(signal);
  exh->Reset();
}

void Exception_Handler::SignalHandler(int signal) 
{
  m_signal=signal;
  m_print=true;
  std::string input="y";
  msg.Error()<<std::endl<<om::bold<<"Exception_Handler::SignalHandler: "
	     <<om::reset<<om::blue<<"Signal "<<om::reset<<om::bold
	     <<"("<<om::red<<signal<<om::reset<<om::bold<<")"
	     <<om::reset<<om::blue<<" caught. "<<om::reset<<std::endl;
  switch (signal) {
  case SIGSEGV:
    ++m_nsegv;
    GenerateStackTrace(std::cout,false);
    if (!rpa.gen.BatchMode()) {
      msg.Error()<<"   Do you want to debug the program (y/n)? "<<om::reset;
      std::cin>>input;
      if (input=="y" || input=="Y") {
	system(("gdb "+m_progname+" "+ToString(getpid())).c_str());
	kill(getpid(),9);
      }
    }
    if (m_nsegv>3) {
      msg.Error()<<om::reset<<"   Abort immediately."<<om::reset<<std::endl;
      kill(getpid(),9);
    }
  case SIGABRT:
    if (!m_active && m_prepared) abort();
  case SIGTERM:
  case SIGXCPU:
    msg.Error()<<om::reset<<"   Cannot continue."<<om::reset<<std::endl;
    m_exitcode=2;
    Terminate();
    break;
  case SIGINT:
    if (!rpa.gen.BatchMode()) {
      msg.Error()<<"   Do you want to stop the program (y/n/k/p/d/s)? "
		 <<om::reset;
      std::cin>>input;
    }
    if (input=="k" || input=="K") {
      kill(getpid(),9);
    }
    else if (input=="p" || input=="P") {
      bool print=m_print;
      m_print=true;
      PrepareTerminate();
      m_print=print;
      std::cin.get();
    }
    else if (input=="d" || input=="D") {
      system(("gdb "+m_progname+" "+ToString(getpid())).c_str());
    }
    else if (input=="s" || input=="S") {
      GenerateStackTrace(std::cout,false);
      std::cout<<" Hit <return> to continue. ";      
      std::cin.get();
      std::cin.get();
    }
    if (input!="y" && input!="Y") return;
    m_exitcode=1;
    Terminate();
    break;
  case SIGBUS:
    ++m_nbus;
    if (m_nbus>3) {
      msg.Error()<<om::reset<<"   Abort immediately."<<om::reset<<std::endl;
      kill(getpid(),9);
    }
    GenerateStackTrace(std::cout,false);
    msg.Error()<<om::reset<<"   Cannot continue."<<om::reset<<std::endl;
    m_exitcode=3;
    Terminate();
    break;
  case SIGFPE:
    msg.Error()<<"   Floating point exception."<<om::reset<<std::endl;
    m_exitcode=1;
    Terminate();
    break;
  default:
    msg.Error()<<"   Cannot handle signal."<<om::reset<<std::endl;
    m_exitcode=1;
    Terminate();
  }
}

void Exception_Handler::GenerateStackTrace(std::ostream &ostr,
					   const bool endline,
					   const std::string &comment)
{
#ifdef USING_Stack_Trace
  ostr<<comment<<om::bold<<"Exception_Handler::GenerateStackTrace(..): "
      <<om::reset<<om::blue<<"Generating stack trace "<<om::reset
      <<"(adapted from ROOT version 3.10) "<<om::bold<<"\n{"
      <<om::reset<<std::endl;
  // adapted from root version 3.10 TUnixSystem.cxx
  void *trace[MAX_BACKTRACE_DEPTH];
  int depth=backtrace(trace,MAX_BACKTRACE_DEPTH);
  for (int n=0; n<depth;++n) {
    unsigned long addr=(unsigned long)trace[n];
    Dl_info info;
    if (dladdr(trace[n],&info) && info.dli_fname && info.dli_fname[0]) {
      unsigned long symaddr=(unsigned long)info.dli_saddr;
      const char *symname=info.dli_sname;
      if (!info.dli_sname || !info.dli_sname[0]) symname="<unknown>";
      ostr<<comment<<om::bold<<"   0x"<<std::setiosflags(std::ios::left)
	  <<std::setw(8)<<std::hex<<symaddr<<std::dec<<om::reset
	  <<" in   '"<<om::red<<symname<<om::reset
	  <<"'\n                from '"<<om::brown<<info.dli_fname
	  <<om::reset<<"'"<<std::endl;
    } 
    else {
      ostr<<comment<<"   "<<addr<<" in   <unknown function>"<<std::endl;
    }
  }
  ostr<<comment<<om::bold<<"}"<<om::reset;
  if (endline) ostr<<std::endl;
#endif
}

void Exception_Handler::SetActive(const bool active)    
{ 
  Init(); 
  exh->m_active=active; 
}

void Exception_Handler::SetStackTrace(const bool trace) 
{ 
  Init(); 
  exh->m_stacktrace=trace;  
}

void Exception_Handler::SetProgramName(const std::string &name)
{ 
  Init(); 
  exh->m_progname=name; 
}

bool Exception_Handler::Active()     
{ 
  Init(); 
  return exh->m_active;     
}

bool Exception_Handler::StackTrace() 
{ 
  Init(); 
  return exh->m_stacktrace; 
}

Exception *Exception_Handler::LastException() 
{ 
  Init(); 
  return exh->m_exception; 
}

unsigned int Exception_Handler::LastSignal()    
{ 
  Init(); 
  return exh->m_signal;    
}

