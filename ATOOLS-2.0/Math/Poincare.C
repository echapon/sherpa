#include "Poincare.H"

#include "MathTools.H"
#include "Message.H"

using namespace ATOOLS;

Poincare::Poincare(): 
  m_status(0), m_beta(1.,0.,0.,0.), m_rsq(1.), m_usen(false)
{
}
  
Poincare::Poincare(Vec4D v1, Vec4D v2):
  m_status(2), m_beta(1.,0.,0.,0.), m_rsq(1.), m_usen(false)
{
  ATOOLS::Vec3D b(v1), a(v2);
  m_ct=a*b/(a.Abs()*b.Abs());
  m_n=Vec4D(0.0,cross(a,b));
  m_nsq=m_n.PSpat2();
  m_nabs=sqrt(m_nsq);
  m_usen=m_n.PSpat2()>0.0 && m_ct<1.0;
  if(sqr(m_ct)>1.0) {
    std::cout.precision(32);
    msg.Error()<<METHOD<<"(): cos^2\\theta > 1. cos\\theta="<<m_ct
	       <<". Accordingly, set it to +-1. ";
    std::cout.precision(6);
    if(m_ct>0.0) m_ct=1.0; else m_ct=-1.0;
    msg.Error()<<(m_usen ? "Will" : "Won't")<<" rotate."<<std::endl;
  }
  m_st=-sqrt(1.0-sqr(m_ct));
  if (m_usen) {
    a=1.0/a.Abs()*a;
    b=1.0/b.Abs()*b;
    Vec3D n(m_n), at(n*(n*a)/m_nsq), ap(a-at);
    Vec3D ta(at+m_ct*ap-m_st/m_nabs*cross(n,ap));
    if (!ATOOLS::IsZero((ta-b).Sqr())) 
      msg.Error()<<METHOD<<"(): Inaccurate rotation {\n"
 		 <<"  a    = "<<a<<"\n"
		 <<"  b    = "<<b<<"\n"
		 <<"  a'   = "<<ta<<" -> rel. dev. ("
		 <<ta[1]/b[1]-1.0<<","<<ta[2]/b[2]-1.0<<","
		 <<ta[3]/b[3]-1.0<<")\n"
		 <<"  m_ct = "<<m_ct<<"\n"
		 <<"  m_st = "<<m_st<<"\n"
		 <<"  m_n  = "<<Vec3D(m_n)
		 <<"\n}"<<std::endl;
  }
}
  
Poincare::Poincare(Vec4D v): 
  m_status(1), m_beta(v), m_rsq(v.Mass()), m_usen(false)
{
}
   
void Poincare::Boost(Vec4D& v)
{
  double v0((m_beta[0]*v[0]-Vec3D(m_beta)*Vec3D(v))/m_rsq);
  double c1((v[0]+v0)/(m_rsq+m_beta[0]));
  v=Vec4D(v0,Vec3D(v)-c1*Vec3D(m_beta)); 
}
  
void Poincare::BoostBack(Vec4D& v)
{
  double v0((m_beta[0]*v[0]+Vec3D(m_beta)*Vec3D(v))/m_rsq);
  double c1((v[0]+v0)/(m_rsq+m_beta[0]));
  v=Vec4D(v0,Vec3D(v)+c1*Vec3D(m_beta));  
}
  
  
void Poincare::Rotate(Vec4D& v)
{
  if (m_usen) {
    Vec3D n(m_n), a(v), at(n*(n*a)/m_nsq), ap(a-at);
    v=Vec4D(v[0],at+m_ct*ap+m_st/m_nabs*cross(n,ap));
  }
}
  
void Poincare::RotateBack(Vec4D& v)
{
  if (m_usen) {
    Vec3D n(-1.0*m_n), a(v), at(n*(n*a)/m_nsq), ap(a-at);
    v=Vec4D(v[0],at+m_ct*ap+m_st/m_nabs*cross(n,ap));
  }
}
  

bool Poincare::CheckBoost() 
{
  if (m_beta.Abs2()<=0.) return false;
  return true;
}

bool Poincare::CheckRotation() 
{
  if (m_usen) {
    if ((!(m_ct>=0) && !(m_ct<0)) || (!(m_st>=0) && !(m_st<0)) ||
	m_n.Nan()) return false;
  }
  return true;
}

void Poincare::Invert() 
{
  for (short unsigned int i(1);i<4;++i) m_beta[i]=-m_beta[i];
  m_n=-1.0*m_n;
}
