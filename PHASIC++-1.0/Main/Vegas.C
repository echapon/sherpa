#include "Vegas.H"
#include <iostream>
#include "MathTools.H"
#include <vector>
#include <stdlib.h>
#include "Run_Parameter.H"

using namespace ATOOLS;
using namespace PHASIC;
using namespace std;

int Vegas::s_onext=-1;

Vegas::Vegas(int dim,int ndx,const std::string & name,int opt)
{
  Data_Read dr(rpa.GetPath()+string("/Integration.dat"));
  m_on = dr.GetValue<Switch::code>("VEGAS");
  if (m_on==NotDefined<Switch::code>()) m_on=Switch::On;
  if (s_onext>-1) m_on=s_onext;
  m_dim  = dim;
  m_sum  = 0.;
  m_sum2 = 0.;
  m_nopt = 0;
  m_nevt = 0;
  m_snevt = 0;
  m_name = name;
  m_mode=0;
  m_nd = ndx;
  m_alpha = 1.;
  p_x   = new double[m_dim];
  if (m_on!=0) {
    p_xi = new double*[m_dim];
    p_bestxi = new double*[m_dim];
    p_d  = new double*[m_dim];
    p_di  = new double*[m_dim];
    p_hit= new int*[m_dim]; 
    for(int i=0;i<m_dim;i++) {
      p_xi[i] = new double[m_nd];
      p_bestxi[i] = new double[m_nd];
      p_d[i]  = new double[m_nd];
      p_di[i]  = new double[m_nd];
      p_hit[i]= new int[m_nd]; 
    }
    p_dt  = new double[m_dim];
    p_chi = new double[m_dim];
    p_bestchi = new double[m_dim];
    p_xin = new double[m_nd];
    p_r   = new double[m_nd];
    p_ia  = new int[m_dim];
    p_opt = new int[m_dim];
    for (int i=0;i<m_dim;i++) {
      p_xi[i][0]=1.0;
      p_opt[i]=1;
      p_bestchi[i]=.0;
      for (int j=0;j<m_nd;j++) {
	p_d[i][j]=0.;
	p_di[i][j]=0.;
	p_hit[i][j]=0;
      }
    }
    for (int i=0;i<m_nd;i++) p_r[i]=1.0;
    p_xin[m_nd-1] = 1.;
    for (int i=0;i<m_dim;i++) Rebin(1./double(m_nd),p_xi[i]);
    m_nc = pow(double(m_nd),double(m_dim));
    for (int j=0;j<m_dim;j++) for (int i=0;i<m_nd;i++) p_bestxi[j][i]=p_xi[j][i];
  }
}

Vegas::~Vegas() 
{
  delete[] p_x;
  if (m_on==0) return;
  for(int i=0;i<m_dim;i++) {
    delete[] p_xi[i];
    delete[] p_bestxi[i];
    delete[] p_d[i];
    delete[] p_di[i];
    delete[] p_hit[i];
  }
  delete[] p_xi;
  delete[] p_bestxi;
  delete[] p_d;
  delete[] p_di;
  delete[] p_hit;
  delete[] p_dt;
  delete[] p_xin;
  delete[] p_chi;
  delete[] p_bestchi;
  delete[] p_r;
  delete[] p_ia;
  delete[] p_opt;
}

void Vegas::Rebin(double rc, double * xi)
{
  int i,k=-1;
  double dr=0.0,xn=0.0,xo=0.;
  
  for (i=0;i<m_nd-1;i++) {
    while (rc > dr) {
      dr += p_r[++k];
      xo=xn;
      xn=xi[k];
    }
    dr -= rc;
    p_xin[i]=xn-(xn-xo)*dr/p_r[k];
  }
  for (i=0;i<m_nd;i++) xi[i]=p_xin[i];
}

double* Vegas::GeneratePoint(const double * ran) 
{
  if (m_on==0) {
    for (int i=0;i<m_dim;i++) p_x[i]=ran[i];
    return p_x;
  }
  m_mode=1;
  double xx;
  int ia;
  for (int i=0;i<m_dim;i++) {
    xx = ran[i]*(double)m_nd;
    ia = (int)xx;
    if (ia>=m_nd) {
      msg_Out()<<" WARNING Vegas::GeneratePoint(const double* ran)"
	       <<" called with ran["<<i<<"]="<<ran[i]<<"\n";
      ia=m_nd-1;
    }
    if (ia==0) {
      p_x[i] = xx*p_xi[i][0];
    }
    else {
      p_x[i] = p_xi[i][ia-1]+(xx-ia)*(p_xi[i][ia]-p_xi[i][ia-1]);
    }
  }
  return p_x;
}

double Vegas::GenerateWeight(double* xy)
{
  if (m_on==0) return 1.;
  m_weight = m_nc;
  for (int i=0;i<m_dim;i++) {
    int k=0;
    while (xy[i]>p_xi[i][k]&&k<m_nd) k++;
    if (k>=m_nd) {
      msg_Out()<<" WARNING Vegas::GenerateWeight(double* xy) called with"
	       <<" xy["<<i<<"]="<<xy[i]<<"\n";
      k=m_nd-1;
    }
    p_ia[i] = k;
    if (k==0) {
      m_weight *= p_xi[i][k];
    }
    else {
      m_weight *= p_xi[i][k]-p_xi[i][k-1];
    }
  }
  return m_weight;
}

void Vegas::AddPoint(double value,double *xy)
{ if (m_on==0) return;
  if (m_mode==1){
    for (int i=0;i<m_dim;i++) {
      if (dabs(p_x[i]-xy[i])>1.e-4) {
	msg_Error()<<"Mapping error in Vegas for "<<m_name<<endl;
	for (int j=0;j<m_dim;j++) msg_Error()<<j<<": "<<p_x[j]<<"<->"<<xy[j]<<" ("<<dabs(p_x[j]-xy[j])<<")"<<endl;
//    	abort();
	i=m_dim;
      }
    }
  }
  for (int i=0;i<m_dim;i++) {
    int k=0;
    while (xy[i]>p_xi[i][k]&&k<m_nd) k++;
    if (k>=m_nd) {
      msg_Out()<<" WARNING Vegas::AddPoint(double value,double* xy) called with"
	       <<" xy["<<i<<"]="<<xy[i]<<"\n";
      k=m_nd-1;
    }
    p_ia[i] = k;
  }
  ++m_nevt;
  m_sum += value;
  double v2 = value*value;
  m_sum2+= v2;
  for (int i=0;i<m_dim;i++) {
    p_d[i][p_ia[i]]+=v2;
    p_di[i][p_ia[i]]+=v2*v2;
    p_hit[i][p_ia[i]]++;
  }
  m_mode=0;
}


void Vegas::Reset()
{
  for (int i=0;i<m_dim;i++) {
    for (int j=0;j<m_nd;j++) {
      p_d[i][j]=p_di[i][j]=0.;
      p_hit[i][j]=0;
    }
  }
  m_snevt=m_nevt;
}

void Vegas::Optimize()
{ 
  if (m_on==0) return;
  if (m_nevt-m_snevt<(unsigned int)m_nd*20) return;
  msg_Tracking()<<"Vegas optimize "<<m_name<<" "<<m_nopt<<" |"<<m_nevt-m_snevt<<endl;
  for (int j=0;j<m_dim;j++) if(p_opt[j]) {
    for (int i=0;i<m_nd;i++) {if(p_hit[j][i]) p_d[j][i]/=p_hit[j][i];
     if (p_hit[j][i]<2) p_hit[j][i]=2;
    }
    double av=0.,av2=0.;
    for (int i=0;i<m_nd;i++)av+=p_d[j][i];
    av/=m_nd;
    for (int i=0;i<m_nd;i++)av2+=sqr(p_d[j][i]);
    av2/=m_nd;
    double ts = sqrt((av2-sqr(av))/(m_nd-1));
    double chi=0.;
    double s2;
    double cx;
    for (int i=0;i<m_nd;i++){
      s2=(p_di[j][i]/p_hit[j][i] - sqr(p_d[j][i]))/(p_hit[j][i]-1);
      cx=sqr(p_d[j][i]-av)/s2;
      if ((p_d[j][i]<av && cx>1.e4) || !(cx>=0.)) cx=1.e4;
      chi+=cx;
    }
    chi=sqrt(chi/m_nd);
    if (m_nopt==0||chi<p_chi[j]) {
      p_chi[j]=chi;
      for (int i=0;i<m_nd;i++) p_bestxi[j][i]=p_xi[j][i];
    }
    if (chi<=1.1) {
      p_opt[j]=0;
      for (int i=0;i<m_nd;i++) p_bestxi[j][i]=p_xi[j][i];
    }
    if (chi>2.*p_chi[j] && ts>p_bestchi[j] && m_nopt>=10) {
      p_opt[j]=0;
      for (int i=0;i<m_nd;i++) p_xi[j][i]=p_bestxi[j][i];
    }
    if (ts<p_bestchi[j]) p_bestchi[j]=ts;
  

    msg_Tracking()<<"Chi"<<j<<" ="<<chi<<"   "<<p_chi[j]<<"("<<p_opt[j]<<")"<<endl;
  }
  double xo,xn,rc;
  for (int j=0;j<m_dim;j++) if(p_opt[j]) {
    xo=p_d[j][0];
    xn=p_d[j][1];
     p_d[j][0]=(xo+xn)/2.0;
     p_dt[j]=p_d[j][0];
     for (int i=1;i<m_nd-1;i++) {
       rc=xo+xn;
       xo=xn;
       xn=p_d[j][i+1];
       p_d[j][i] = (rc+xn)/3.0;
       p_dt[j] += p_d[j][i];
      }
    p_d[j][m_nd-1]=(xo+xn)/2.0;
    p_dt[j] += p_d[j][m_nd-1];
  }
  for (int j=0;j<m_dim;j++) if(p_opt[j]) {
    rc=0.0;
    for (int i=0;i<m_nd;i++) {
     if (p_d[j][i] < p_dt[j]*1.e-10) p_d[j][i]=p_dt[j]*1.e-10;
      p_r[i]=pow((1.0-p_d[j][i]/p_dt[j])/
	       (log(p_dt[j])-log(p_d[j][i])),m_alpha);
      rc += p_r[i];
    }
    Rebin(rc/double(m_nd),p_xi[j]);
  }
  m_nopt++;
  Reset();
}

void Vegas::EndOptimize()
{ 
  if (m_on==0||m_nopt==0) return;
  msg_Tracking()<<"Vegas EndOptimize:"<<endl;
  for (int j=0;j<m_dim;j++) msg_Tracking()<<" "<<p_chi[j];
  msg_Tracking()<<endl;
  for (int j=0;j<m_dim;j++)
    for (int i=0;i<m_nd;i++) p_xi[j][i]=p_bestxi[j][i]; 
}

void Vegas::WriteOut(const std::string & pid)
{
  std::string fn=pid+std::string("_")+m_name+std::string("_Vegas");
  std::ofstream ofile(fn.c_str());

  ofile<<m_nopt<<" "<<m_dim<<" "<<m_name<<std::endl;
  if (m_nopt>0) {
    ofile.precision(12);
    for (int i=0;i<m_dim;i++) {
      ofile<<"(";
      for (int j=0;j<m_nd;j++) {
	if (j!=0) ofile<<",";
	ofile<<p_xi[i][j];
      }
      ofile<<")"<<endl;
    }
    for (int i=0;i<m_dim;i++) {
      ofile<<p_opt[i]<<" "<<p_chi[i]<<" (";
      for (int j=0;j<m_nd;j++) {
	if (j!=0) ofile<<",";
	ofile<<p_bestxi[i][j];
      }
      ofile<<")"<<endl;
    }
  }
  ofile.close();
}

void Vegas::ReadIn(const std::string & pid)
{
  std::string fn=pid+std::string("_")+m_name+std::string("_Vegas");
  std::ifstream ifile(fn.c_str());
  if (ifile.bad()) return;
  ifile>>m_nopt;
  if (m_nopt==0||m_on==0) return;
  std::string buffer;
  int number;
  ifile>>number;
  getline(ifile,buffer);
  msg_Tracking()<<"Vegas::ReadIn "<<buffer<<" with "<<number<<" dimensions; nopt="<<m_nopt<<std::endl;
  if (number!=m_dim) {
    msg_Error()<<"Error Vegas::ReadIn() - wrong dimension!"<<endl;
    abort();
  }
  for (int i=0;i<m_dim;++i) {
    getline(ifile,buffer);
    size_t  a=buffer.find("(")+1;
    size_t  b=buffer.find(")");
    char * err;
    buffer=buffer.substr(a,b-a);
    for (int j=0;j<m_nd;++j) {
      size_t c=buffer.find(",");
      p_xi[i][j]=strtod(buffer.substr(0,c).c_str(),&err);
      buffer=buffer.substr(c+1);
    }
  }
  for (int i=0;i<m_dim;++i) {
    ifile>>p_opt[i]>>p_chi[i];
    getline(ifile,buffer);
    size_t  a=buffer.find("(")+1;
    size_t  b=buffer.find(")");
    char * err;
    buffer=buffer.substr(a,b-a);    
    for (int j=0;j<m_nd;++j) {
      size_t c=buffer.find(",");
      p_bestxi[i][j]=strtod(buffer.substr(0,c).c_str(),&err);
      buffer=buffer.substr(c+1);
    }
  }
}


