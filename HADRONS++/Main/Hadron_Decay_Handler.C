#include "HADRONS++/Main/Hadron_Decay_Handler.H"
#include "ATOOLS/Org/Message.H"
#include "ATOOLS/Phys/Blob.H"
#include "ATOOLS/Phys/Blob_List.H"
#include "ATOOLS/Phys/Particle.H"
#include "ATOOLS/Org/Run_Parameter.H"
#include "HADRONS++/Main/Hadron_Decay_Map.H"
#include "HADRONS++/Main/Hadron_Decay_Table.H"
#include "HADRONS++/Main/Hadron_Decay_Channel.H"
#include "HADRONS++/Main/Mixing_Handler.H"
#include "METOOLS/SpinCorrelations/Spin_Density.H"
#include "METOOLS/SpinCorrelations/Decay_Matrix.H"
#include <algorithm>

using namespace ATOOLS;
using namespace PHASIC;
using namespace std;
using namespace HADRONS;
using namespace METOOLS;

Hadron_Decay_Handler::Hadron_Decay_Handler(string path, string fragfile) :
  Decay_Handler()
{
  Data_Reader dr(" ",";","!","=");
  dr.AddWordSeparator("\t");
  dr.SetInputPath(path);
  dr.SetInputFile(fragfile);

  double max_propertime = dr.GetValue<double>("MAX_PROPER_LIFETIME",-1.0);
  if( max_propertime > 0.0) {
    for(KFCode_ParticleInfo_Map::const_iterator kfit(s_kftable.begin());
	kfit!=s_kftable.end();++kfit) {
      Flavour flav(kfit->first);
      if (flav.IsOn() && flav.IsHadron() && !flav.IsStable() &&
          0.197e-12>max_propertime*flav.Width() && flav.Kfcode()!=kf_K)
      {
        flav.SetStable(true);
      }
    }
  }

  string decaypath=dr.GetValue<string>("DECAYPATH",rpa->gen.Variable("SHERPA_SHARE_PATH"))+"/"
    +dr.GetValue<string>("DECAYPATHPIECE",string("Decaydata/"));
  string decayfile=dr.GetValue<string>("DECAYFILE",string("HadronDecays.dat"));
  string decayconstfile=dr.GetValue<string>("DECAYCONSTFILE",
                                            string("HadronConstants.dat"));
  string bdecayfile=dr.GetValue<string>("B_DECAYFILE",
					string("Partonic_b/Decays.dat"));
  string cdecayfile=dr.GetValue<string>("C_DECAYFILE",
					string("Partonic_c/Decays.dat"));
  string aliasfile=dr.GetValue<string>("HADRONALIASESFILE",
                                       string("HadronAliases.dat"));
  string aliasdecayfile=dr.GetValue<string>("ALIASDECAYFILE",
                                            string("AliasDecays.dat"));

  My_In_File::OpenDB(decaypath);
  My_In_File::ExecDB(decaypath,"PRAGMA cache_size = 100000");
  My_In_File::ExecDB(decaypath,"BEGIN");
  Hadron_Decay_Map * dmap = new Hadron_Decay_Map(this);
  dmap->ReadInConstants(decaypath, decayconstfile);
  dmap->ReadInPartonicDecays(Flavour(kf_b),decaypath,bdecayfile);
  dmap->ReadInPartonicDecays(Flavour(kf_c),decaypath,cdecayfile);
  dmap->ReadHadronAliases(decaypath, aliasfile);
  dmap->Read(decaypath, decayfile, true);
  dmap->Read(decaypath, aliasdecayfile);
  dmap->Initialise();
  dmap->ReadFixedTables("", "FixedDecays.dat");
  p_decaymap=dmap;
  
  int decay_tau_hard=dr.GetValue<int>("DECAY_TAU_HARD",0);
  for (Decay_Map::iterator it=p_decaymap->begin(); it!=p_decaymap->end(); ++it) {
    Flavour flav(it->first);
    if (flav.Kfcode()==kf_tau && decay_tau_hard) continue;
    flav.SetDecayHandler(this);
  }
  
  p_mixinghandler = new Mixing_Handler();
  p_mixinghandler->SetModel(dmap->StartModel());
  dmap->SetMixingHandler(p_mixinghandler);
  My_In_File::ExecDB(decaypath,"END");
  My_In_File::CloseDB(decaypath);
}

Hadron_Decay_Handler::~Hadron_Decay_Handler()
{
  Hadron_Decay_Map* dmap=dynamic_cast<Hadron_Decay_Map*>(p_decaymap);
  delete dmap; p_decaymap=NULL;
  delete p_mixinghandler; p_mixinghandler=NULL;
}

bool Hadron_Decay_Handler::VetoDecayAndPrepForNew(ATOOLS::Blob* blob)
{
  if (blob->Has(blob_status::needs_showers)) return false;

  if (blob->Type()==btp::Hadron_Decay && (*blob)["Partonic"]!=NULL) {
    if (RejectExclusiveChannelsFromFragmentation(blob)) {
      return true;
    }
  }
  return false;
}

void Hadron_Decay_Handler::BeforeFillDecayTree(Blob * blob)
{
  p_mixinghandler->PerformMixing(blob->InParticle(0));
}

Amplitude2_Tensor*
Hadron_Decay_Handler::FillOnshellDecay(Blob *blob, Spin_Density* sigma)
{
  Amplitude2_Tensor* amps=Decay_Handler::FillOnshellDecay(blob,sigma);
  Decay_Channel* dc=(*blob)["dc"]->Get<Decay_Channel*>();
  Hadron_Decay_Channel* hdc=dynamic_cast<Hadron_Decay_Channel*>(dc);
  if(hdc && !hdc->SetColorFlow(blob)) {
    msg_Error()<<METHOD<<" failed to set color flow, retrying event."<<endl
               <<*blob<<endl;
    throw Return_Value::Retry_Event;
  }
  return amps;
}

void Hadron_Decay_Handler::CreateDecayBlob(Blob_List* bloblist, Particle* inpart)
{
  DEBUG_FUNC(inpart->RefFlav());
  if(inpart->DecayBlob()) THROW(fatal_error,"Decay blob already exists.");
  if(inpart->Time()==0.0) inpart->SetTime();
  Blob* blob = bloblist->AddBlob(btp::Hadron_Decay);
  blob->SetStatus(blob_status::needs_extraQED);
  blob->AddToInParticles(inpart);
  SetPosition(blob);
  blob->SetTypeSpec("Sherpa");
  Decay_Table* table=p_decaymap->FindDecay(blob->InParticle(0)->Flav());
  if (table==NULL) {
    msg_Error()<<METHOD<<" decay table not found, retrying event."<<endl
               <<*blob<<endl;
    throw Return_Value::Retry_Event;
  }
  blob->AddData("dc",new Blob_Data<Decay_Channel*>(table->Select()));

  blob->AddData("p_onshell",new Blob_Data<Vec4D>(inpart->Momentum()));
  DEBUG_VAR(inpart->Momentum());
}

void Hadron_Decay_Handler::SetPosition(ATOOLS::Blob* blob)
{
  Particle* inpart = blob->InParticle(0);
  if(inpart->Flav().Kfcode()==kf_K) {
    blob->SetPosition(inpart->XProd());
    return;
  }
  
  // boost lifetime into lab
  double gamma = 1./rpa->gen.Accu();
  if (inpart->Flav().HadMass()>rpa->gen.Accu()) {
    gamma = inpart->E()/inpart->Flav().HadMass();
  }
  else {
    double q2    = dabs(inpart->Momentum().Abs2());
    if (q2>rpa->gen.Accu()) gamma = inpart->E()/sqrt(q2);
  }
  double lifetime_boosted = gamma * inpart->Time();
  
  Vec3D      spatial = inpart->Distance( lifetime_boosted );
  Vec4D     position = Vec4D( lifetime_boosted*rpa->c(), spatial );
  blob->SetPosition( inpart->XProd() + position ); // in mm
}

bool Hadron_Decay_Handler::RejectExclusiveChannelsFromFragmentation(Blob* decblob)
{
  if (decblob->Type()!=btp::Hadron_Decay || (*decblob)["Partonic"]==NULL)
    return false;

  DEBUG_FUNC(decblob->InParticle(0)->Flav());
  Return_Value::IncCall(METHOD);
        
  bool anti=false;
  Decay_Map::iterator dt=
    p_decaymap->find(decblob->InParticle(0)->Flav());
  if (dt==p_decaymap->end()) {
    anti=true;
    dt=p_decaymap->find(decblob->InParticle(0)->Flav().Bar());
    if (dt==p_decaymap->end() || dt->second.size()!=1) {
      PRINT_INFO("Internal error.");
      throw Return_Value::Retry_Event;
    }
  }
  Flavour_Vector tmp, tmpno;
  for(int i=0;i<decblob->NOutP();i++) {
    Flavour flav(anti?decblob->OutParticle(i)->Flav().Bar():
                 decblob->OutParticle(i)->Flav());
    tmp.push_back(flav);
    if (!flav.IsPhoton()) tmpno.push_back(flav);
  }
  
  std::sort(tmp.begin(), tmp.end(), Decay_Channel::FlavourSort);
  Flavour_Vector compflavs(tmp.size()+1), compflavsno(tmpno.size()+1);
  compflavs[0]=(anti?decblob->InParticle(0)->Flav().Bar():decblob->InParticle(0)->Flav());
  for (size_t i=0; i<tmp.size(); ++i) compflavs[i+1]=tmp[i];
  if (tmpno.size()!=tmp.size()) {
    std::sort(tmpno.begin(), tmpno.end(), Decay_Channel::FlavourSort);
    compflavsno[0]=(anti?decblob->InParticle(0)->Flav().Bar():
                    decblob->InParticle(0)->Flav());
    for (size_t i=0; i<tmpno.size(); ++i) compflavsno[i+1]=tmpno[i];
  }
  
  if (dt->second[0]->GetDecayChannel(compflavs) ||
      (tmpno.size()!=tmp.size() && 
       dt->second[0]->GetDecayChannel(compflavsno))) {
    Return_Value::IncRetryPhase(METHOD);
    DEBUG_INFO("rejected. retrying decay.");
    decblob->DeleteOutParticles();
    decblob->InParticle(0)->SetStatus(part_status::active);
    decblob->AddStatus(blob_status::internal_flag);
    Flavour infl(decblob->InParticle(0)->Flav());
    Hadron_Decay_Table * hdt = 
      dynamic_cast<Hadron_Decay_Table*>(p_decaymap->FindDecay(infl));
    hdt->Select(decblob);
    return true;
  }
  else {
    DEBUG_INFO("not found as exclusive. accepted.");
    return false;
  }
}

