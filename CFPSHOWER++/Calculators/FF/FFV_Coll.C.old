#include "CFPSHOWER++/Calculators/FF/SF_FF12.H"
#include "CFPSHOWER++/Shower/Kernel.H"
#include "ATOOLS/Org/Message.H"

namespace CFPSHOWER {
  class FFV_coll : public SF_FF12 {
    double B1(const double & z,const double & kappa2) const;
  public:
    FFV_coll(const Kernel_Info & info);
    double operator()(const Splitting & split);
    double Integral(const Splitting & split) const;
    double OverEstimate(const Splitting & split) const;
    void   GeneratePoint(Splitting & split) const;
  };
}

using namespace CFPSHOWER;
using namespace ATOOLS;

FFV_coll::FFV_coll(const Kernel_Info & info)  : SF_FF12(info) {
  SetName("F->FV(coll)");
  msg_Out()<<METHOD<<".\n";
}

double FFV_coll::operator()(const Splitting & split) {
  double z(split.z(0)), kappa2(split.t(0)/split.Q2red());
  // Start with the soft term only, including possible K factors (cusp anomalous
  // dimensions), obtained from the gauge part of the kernel
  double value   = B1(z,kappa2);
  if (split.IsMassive()) {
    // Massive splitting adjustments
    // directly return 0 if the splitting is kinematically not viable
    double mi2(split.m2(0)), mj2(split.m2(1));
    double mk2(split.mspect2()), mij2(split.msplit2()), y(split.y());
    double Q2(split.Q2()), sij(y*(Q2-mk2)+(1.-y)*(mi2+mj2)); // = Q2red + (mi2+mj2)
    double vt2_ij_k(Lambda2(Q2,mij2,mk2)), v2_ij_k(Lambda2(Q2,sij,mk2));
    if ( sij<mi2+mj2 || Q2<sij+mk2 || vt2_ij_k<0. || v2_ij_k < 0.) return 0.;
    double vt_ij_k = sqrt(vt2_ij_k)/(Q2-mij2-mk2), v_ij_k = sqrt(v2_ij_k)/(Q2-sij-mk2);
    // Terms ~y/(1-z+y) come from reshuffling the mass-dependent terms in the eikonal
    // to ensure correct soft behaviour
    value = vt_ij_k/v_ij_k * (B1(z,kappa2) +
			      2.*mi2/(sij-mi2-mj2) * (1.- y/(1.-z+y)) );
    if (mk2>0.) {
      double vt_kj_i = Lambda(Q2,mk2,mi2)/(Q2-mk2-mi2);
      double v_kj_i  = sqrt(1.- 4.*mi2*(Q2*(1.-z)+mk2)/sqr(Q2*z) );
      value  -= (vt_kj_i/v_kj_i  *
		 2.*mk2/(Q2*(1.-z)) * y/(1.-z+y));
    }
  }
  if (split.Clustered()==0) value *= split.ztilde(m_tags[0]); // m_tags[0]==0?z:1.-z;
  //msg_Out()<<METHOD<<" for t = "<<split.t(0)<<", z = "<<split.z(0)<<", "
  //	   <<"y = "<<split.y()<<", ztilde = "<<split.ztilde(0)<<"\n"
  //	   <<"*** "<<split
  //	   <<"*** value = "<<value<<" from B = "<<B1(z,kappa2)<<".\n";
  return value;
}

double FFV_coll::Integral(const Splitting & split) const {
  return 1.;
}

double FFV_coll::OverEstimate(const Splitting & split) const {
  return 1.;
}

void FFV_coll::GeneratePoint(Splitting & split) const {
  double z = ran->Get();
  split.Set_z(0,z);
  split.Set_phi(0);
}

double FFV_coll::B1(const double & z,const double & kappa2) const {
  return (1.-z);
}



DECLARE_GETTER(FFV_coll,"FF_FFV_Coll",SF_Base,Kernel_Info);

SF_Base * ATOOLS::Getter<SF_Base,Kernel_Info,FFV_coll>::
operator()(const Parameter_Type & info) const
{
  if (info.Type()==kernel_type::FF &&
      info.LogType()==log_type::coll &&
      info.GetSplit().IsFermion() && 
      info.GetFlavs()[0].IsFermion() &&
      info.GetFlavs()[1].IsVector()) {
    return new FFV_coll(info);
  }
  return NULL;
}

void ATOOLS::Getter<SF_Base,Kernel_Info,FFV_coll>::
PrintInfo(std::ostream &str,const size_t width) const
{
  str<<"FFV collinear splitting Function (FF)";
}


