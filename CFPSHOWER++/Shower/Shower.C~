#include "CFPSHOWER++/Shower/Shower.H"
#include "CFPSHOWER++/Shower/Kernel.H"
#include "CFPSHOWER++/Calculators/SF_Base.H"
#include "CFPSHOWER++/Shower/Cluster_Definitions.H"
#include "CFPSHOWER++/Tools/CFP_Parameters.H"
#include "CFPSHOWER++/Tools/Kernel_Info.H"
#include "MODEL/Main/Model_Base.H"
#include "MODEL/Main/Single_Vertex.H"
#include "MODEL/Main/Running_AlphaS.H"
#include "PDF/Main/ISR_Handler.H"
#include "ATOOLS/Math/Random.H"
#include "ATOOLS/Org/Run_Parameter.H"
#include "ATOOLS/Org/Default_Reader.H"
#include "ATOOLS/Org/My_Limits.H"
#include "ATOOLS/Org/Message.H"
#include "ATOOLS/Org/Exception.H"

using namespace CFPSHOWER;
//using namespace PHASIC;
using namespace MODEL;
using namespace ATOOLS;
using namespace std;

Shower::Shower():
  p_model(NULL), p_as(NULL), 
  p_cluster(new Cluster_Definitions(this))
{
  p_pdf[1]=p_pdf[0]=NULL;
}

Shower::~Shower()
{
  Reset();
  for (size_t i=0;i<5;i++) {
    while (!m_kernels[i].empty()) {
      delete m_kernels[i].begin()->second;
      m_kernels[i].erase(m_kernels[i].begin());
    }
  }
  delete p_cluster;
}

void Shower::Reset() {
  while (!m_splittings.empty()) {
    delete m_splittings.back();
    m_splittings.pop_back();
  }
}

bool Shower::Evolve(Configuration * config) {
  p_config = config;
  // Initialisation - will have to be shifted to a new method (or some Reset()).
  m_weight = 1.; m_nem = 0;
  if (p_config->T0()<0.) p_config->SetT0(m_t0min);
  // Logic here:
  // 1. As long as we find possible splittings (p_winner) and we have not exhausted
  //    the number of possible emissions (m_nmax_em>m_nem), we continue with the
  //    evolution of the configuration, in step 2.
  // 2. We iterate over all partons in the configuration that have not yet been
  //    switched off and check if they can evolve in Evolve(Parton *):
  //    - If successful this yields a winning splitting, p_winner.  Then we add
  //      the combined acceptance weight for the splitter and rejection weights for
  //      all splittings that failed for this and other partons in the configuration,
  //      in AddWeight().  The winner sets the maximal t for the next evolution step,
  //      and we have to reset the minimal t, t0.  Finally we perform the actual
  //      splitting, in PerformSplitting(), by adding the splitting products and
  //      updating kinematics and colours.  
  //    - If we are not successful we go to step 3.
  // 3. If the evolution of the configuration is over we add a final weight,
  //    consisting of all rejection weights of failed splittings.
  do {
    //msg_Out()<<"#########################################################\n"
    //	     <<"#########################################################\n"
    //	     <<"#########################################################\n"
    //	     <<METHOD<<" for "<<p_config->T()<<" --> "<<p_config->T0()<<".\n";
    p_winner = NULL;
    for (Parton_List::iterator pit=p_config->begin();pit!=p_config->end();pit++) {
      if ((*pit)->On() && !Evolve(*pit)) continue;
    }
    if (p_winner) {
      //msg_Out()<<"Found a winning splitting:\n"<<(*p_winner);
      AddWeight(p_winner->T());
      p_config->SetT(p_winner->T());
      p_config->SetT0(m_t0min);
      if (PerformSplitting()) {
	m_splittings.push_back(p_winner);
	m_nem++;
      }
      else {
	for (Parton_List::iterator pit=p_config->begin();pit!=p_config->end();pit++) {
	  (*pit)->ClearWeights();
	}
	delete p_winner;
	return false;
      }
    }
  } while (p_winner && m_nem<m_nmax_em);
  AddWeight(p_config->T0());
  //msg_Out()<<METHOD<<" finished, weight = "<<m_weight<<", "<<m_nem<<" emissions, "
  //	   <<"--> "<<config->size()<<" partons.\n"
  //	   <<"#########################################################\n"
  //	   <<"#########################################################\n"
  //	   <<"#########################################################\n";
  return true;
}

void Shower::AddWeight(const double & t) {
  double stepweight = 1., partweight;
  for (Parton_List::iterator pit=p_config->begin();pit!=p_config->end();pit++) {
    Parton * part = (*pit);
    stepweight *= partweight = part->GetWeight(t);
    part->ClearWeights();
  }
  m_weight *= stepweight;
}

bool Shower::Evolve(Parton * splitter) {
  // Initialise the integrated splitting kernel, summed over all spectators (at least one
  // in QCD, and maximally two).  If splittings are kinematically allowed, the sum will be
  // larger than one and we will generate a test splitting through GenerateTestSplitting().
  // This test includes splitting parameters t and z, plus corresponding kinematics information
  // (y, z, as well as all masses involved), from which we also construct the four-momenta of
  // the decay products and the spectator.  The kinematics will subsequently be fully realised
  // in PerformSplitting(), by adding the decay products to the configuration, by switching
  // off the splitter, and by updating the spectator kinematics and the colour connections.
  bool success = false;
  if (splitter->GetSpectators()->size()<=0) return false;
  //msg_Out()<<"#########################################################\n"
  //	   <<"#########################################################\n"
  //	   <<METHOD<<" for parton ["<<splitter->Id()<<", "<<splitter->Flav()<<"]: "
  //	   <<splitter->GetSpectators()->size()<<" spectators.\n";
  double sum  = InitialiseIntegrals(splitter);
  if (sum>0.) {
    Splitting * split = GenerateTestSplitting(splitter,sum);
    if (split) {
      success = true;
      // we found a splitting - if we have not found a possible splitting yet,
      // this splitting is the winner.  If we already have a winner, there are
      // two possibilities:
      // 1. the t of the current splitting is larger than the winner to date.
      //    In this case, we delete the winner and replace it with the current trial
      //    splitting (this should become obsolete now).
      // 2. the t of the current splittiere is below the current winner's t.  Then
      //    we just delete the current splitting.  
      if      (p_winner==NULL) p_winner = split;
      else if (split->T() > p_winner->T()) { delete p_winner; p_winner = split; }
      else    delete split;
      // If we have a winning splitter, all contenders must have a larger t, so
      // the winning t is the lower limit t0 of this run.
      if (p_winner) { p_config->SetT0(p_winner->T()); }
    }
  }
  //msg_Out()<<"### out of "<<METHOD<<"("<<splitter->Id()<<") with "<<success<<": ";
  //if (success) msg_Out()<<"t = "<<p_winner->T()<<" > "<<p_winner->T0();
  //msg_Out()<<"\n"
  //	   <<"#########################################################\n"
  //	   <<"#########################################################\n";
  return success;
}

double Shower::InitialiseIntegrals(Parton * splitter) {
  const Parton_List * spectators = splitter->GetSpectators();
  m_dipoles.clear();
  double sum = 0., integral;
  for (Parton_List::const_iterator spit=spectators->begin();
       spit!=spectators->end();spit++) {
    Parton * spectator = (*spit);
    Splitting split(splitter,spectator,p_config->T(),p_config->T0());
    // Select the list of applicable kernels depending on the kinematic configuration
    // and the flavour of the splitter.  Initialise a container "Splitting" for the
    // information defining the potential splitting.
    kernel_type::code type = GetCode((splitter->Beam()>-1),(spectator->Beam()>-1));
    map<Flavour, Kernels *>::iterator kit = m_kernels[int(type)].find(splitter->Flav());
    if (kit==m_kernels[int(type)].end()) {
      return 0.;
      THROW(fatal_error,"No kernels found for splitting type.");
    }
    Kernels * kernels = kit->second;
    kernels->CalcIntegrals(split,p_massselector);
    sum                 += kernels->Integral();
    m_dipoles[spectator] = kernels; 
  }
  return sum;
}
  
Splitting * Shower::GenerateTestSplitting(Parton * splitter,const double & sum) {
  const Parton_List * spectators = splitter->GetSpectators();
  double t = p_config->T(), t0 = p_config->T0();
  //msg_Out()<<"#########################################################\n"
  //	   <<"### start evolution with t = "<<t<<", t_0 = "<<t0<<".\n";
  while (t>t0) {
    double random = ran->Get();
    t *= exp(log(random)/sum);
    if (t<t0) return NULL;
    double disc = sum * ran->Get();
    Parton * spectator;
    Kernels * kernels;
    for (Parton_List::const_iterator spit=spectators->begin();
	 spit!=spectators->end();spit++) {
      spectator = (*spit);
      kernels   = m_dipoles[spectator];
      disc     -= kernels->Integral();
      if (disc<=0 && kernels->SelectOne()) {
	Splitting * split = new Splitting(splitter,spectator,t,t0);
	// For a valid evolution parameter t, select a kernel according to the overestimated
	// integral and attach the kernel to the splitting information
	Kernel * kernel   = kernels->GetSelected();
	//msg_Out()<<" ### next trial t = "<<sqrt(t)<<", with spectator "
	//	 <<spectator->Id()<<", Q2 = "<<split->Q2()<<", "
	//	 <<kernel->GetSF()->Name()<<".\n";
	// Veto and adding of weights is embedded here.
	// Generate z, phi, run the veto algorithm, and construct the kinematics.  If everything
	// works out, the splitting is allowed and we keep it.  Rejected splittings add to the
	// rejection weight related to the parton.
	if (kernel->Generate(*split,p_massselector,m_weightover)) return split;
	else delete split;
	break;
      }
    }
  }
  // Didn't find a meaningful splitting for the parton in all kernels.
  return NULL;
}

bool Shower::PerformSplitting() {
  if (!p_winner->GetKernel()->FillOffsprings((*p_winner))) {
    msg_Error()<<METHOD<<" failed to set colours for splitting:\n"<<(*p_winner)
	       <<"   Return false and hope for the best.\n";
    return false;
  }
  EstablishSpectators(p_winner->GetSplitter());
  p_winner->UpdateSpectatorMomentum();
  return true;
}

void Shower::EstablishSpectators(Parton * splitter) {
  const Parton_List * spectators = splitter->GetSpectators();
  vector<unsigned int> cols;  cols.resize(2);
  for (size_t i=0;i<3;i++) {
    Parton * offspring = p_winner->GetParton(i);
    if (offspring==NULL) continue;
    //msg_Out()<<" *** establish connections for "<<offspring->Id()<<"\n";   
    for (size_t col=0;col<2;col++) { cols[col] = offspring->GetColor()[col]; }
    for (size_t j=i+1;j<3;j++) {
      Parton * compare = p_winner->GetParton(j);
      if (compare==NULL) continue;
      for (size_t col=0;col<2;col++) {
	if (cols[col]!=0 && cols[col]==compare->GetColor()[1-col]) {
	  if (!offspring->FindSpectator(compare)) {
	    offspring->AddSpectator(compare);
	    compare->AddSpectator(offspring);
	    //msg_Out()<<"   * add pairing with offspring "<<compare->Id()
	    //	     <<" for col["<<col<<"] = "<<cols[col]<<"\n";
	  }
	}
      }
    }
    for (Parton_List::const_iterator spec=spectators->begin();
	 spec!=spectators->end();spec++) {
      Parton * spectator = (*spec);
      for (size_t col=0;col<2;col++) {
	if (cols[col]!=0 && cols[col]==spectator->GetColor()[1-col]) {
	  if (!offspring->FindSpectator(spectator)) {
	    //msg_Out()<<"   * add pairing with spectator "<<spectator->Id()
	    //	     <<" for col["<<col<<"] = "<<cols[col]<<"\n";
	    offspring->AddSpectator(spectator);
	  }
	  if (!spectator->FindSpectator(offspring)) spectator->AddSpectator(offspring);
	}
      }
    }
    p_config->push_back(offspring);
  }
  for (Parton_List::const_iterator spec=spectators->begin();
       spec!=spectators->end();spec++) {
    (*spec)->RemoveSpectator(splitter);
  }
  splitter->SwitchOff();
}


bool Shower::Init(MODEL::Model_Base * const model,
		  PDF::ISR_Handler * const isr)
{
  msg_Out()<<"*********************************************\n"
	   <<METHOD<<" starts initializing shower algorithms.\n";
  p_as    = (MODEL::Running_AlphaS*)(model->GetScalarFunction("alpha_S"));
  for (int i=0;i<2;++i) p_pdf[i]=isr->PDF(i);
  return (InitializeParameters() && InitializeKernels(model));
}

bool Shower::InitializeParameters() {
  // Shower parameters and switches are pulled from the map in the CFP_Parameter
  // - parton shower cutoffs for FS and IS showering
  // - order of the splitting function and details of terms included
  // - scale setting schemes
  // - eventually recoil schemes
  m_t0[0]       = (*cfp_pars)("pt2min(FS)");
  m_t0[1]       = (*cfp_pars)("pt2min(IS)");
  m_t0min       = Min(m_t0[0], m_t0[1]);
  m_asfactor[0] = (*cfp_pars)("k_alpha(FS)");
  m_asfactor[1] = (*cfp_pars)("k_alpha(IS)");
  m_muR2factor  = (*cfp_pars)("k_muR");
  m_muF2factor  = (*cfp_pars)("k_muF");
  m_kinscheme   = (*cfp_pars)["kinematics"];
  m_kfactor     = (*cfp_pars)["kfactor"];
  m_cplscheme   = (*cfp_pars)["couplings"];
  m_MEcorrs     = (*cfp_pars)["ME_corrections"];
  m_nmax_em     = (*cfp_pars)["max_emissions"];
  m_weightover  = 3.;
  //m_parameters["PDF_min"]      = reader->Get<double>("CSS_PDF_MIN",1.0e-4);
  //m_parameters["PDF_min_X"]    = reader->Get<double>("CSS_PDF_MIN_X",1.0e-2);
  return true;
}

bool Shower::InitializeKernels(MODEL::Model_Base * const model) {
  msg_Out()<<"*********************************************\n"
	   <<METHOD<<" starts collecting splitting kernels.\n"
	   <<"** available kernels:\n";
  SF_Getter::PrintGetterInfo(msg->Out(),25);
  GP_Getter::PrintGetterInfo(msg->Out(),25);
  msg_Out()<<"\n";
  // Going through vertex tables and translating 3-particle vertices into splitting
  // kernels.  The kernels consist of a splitting function and a gauge part, where
  // the latter handles the colour configuration and all aspects realted to the
  // coupling constants at higher orders, while the former encapsulates AP splitting
  // functions, triple-collinear parts, etc..
  // The set of flavour triplets makes sure we do not initialize splitting kernels for
  // any parton configuration more than once.
  std::set<FlavourTriplet> kernel_flavours;
  const Vertex_Table *vtab(model->VertexTable());
  for (Vertex_Table::const_iterator vlit=vtab->begin();
       vlit!=vtab->end();++vlit) {
    for (Vertex_List::const_iterator vit=vlit->second.begin();
	 vit!=vlit->second.end();++vit) {
      MakeKernelsFromVertex((*vit),kernel_flavours);
    }
  }
  msg_Out()<<"*********************************************\n";
  return true;
}

void Shower::MakeKernelsFromVertex(MODEL::Single_Vertex * vertex,
				   std::set<FlavourTriplet> & kernel_flavours) {
  // At LO only 3-particle vertices are allowed and we keep track of such configurations
  // only in the kernel_flavours set.  
  if (vertex->NLegs()>3) return;
  FlavourTriplet orig(vertex->in);
  if (kernel_flavours.find(orig)!=kernel_flavours.end()) return;
  // The kernels are initialised with the information stored in the Kernel_Info
  // struct, which carries information about:
  // - the flavours, organized in the FlavourTriplet orig (a vector of flavours with 3 entries),
  // - their configuration for splitter/spectator in the kernel_type struct (FF, FI, IF, and II)
  // - the vertex (which may carries more information for non-QCD interactions)
  // - pointers to alphaS and alpha(QED)
  // - whether the interaction is "swapped" (example: q->qg vs. q->gq)
  // - to be implemented: order information, masses of partiles, etc..
  // Initialised kernels are organised in 4 maps (one for each of the splitter/spectator
  // configuration), connecting splitting flavours with all possible kernels.  In QCD this means,
  // for each quark there will be two kernels: q->qg and q->gq, and for gluons we will have
  // two g->gg splittings (one for the 1/z and one for the 1/(1-z) pole, captured with "swapped")
  // plus g->q qbar and g->qbar q for six quark flavours.
  Kernel_Info info;
  Kernel * kernel;
  kernel_flavours.insert(orig);
  for (size_t swapped=0;swapped!=2;swapped++) {
    info   = Kernel_Info(vertex,orig.m_flavs,kernel_type::FF,bool(swapped));
    info.SetAlphaS(p_as);
    info.SetKFactor(m_kfactor);
    info.SetCplScheme(m_cplscheme);
    info.SetAsFactor(m_asfactor[0]);
    info.SetMuR2Factor(m_muR2factor);
    kernel = Kernel_Getter::GetObject("Kernel",info);
    if (kernel!=0) {
      if (m_kernels[int(info.Type())].find(info.GetFlavs()[0])==
	  m_kernels[int(info.Type())].end()) {
	m_kernels[int(info.Type())][info.GetFlavs()[0]] = new Kernels();
      }
      m_kernels[int(info.Type())][info.GetFlavs()[0]]->push_back(kernel);
    }
  }
}
