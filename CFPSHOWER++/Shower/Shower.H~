#ifndef CFPShower_Shower_Shower_H
#define CFPShower_Shower_Shower_H

#include "CFPSHOWER++/Shower/Kernels.H"
#include "CFPSHOWER++/Tools/Configuration.H"

namespace ATOOLS {
  class Default_Reader;
}

namespace MODEL {
  class Model_Base;
  class Running_AlphaS;
  class Running_AlphaQED;
  class Single_Vertex;
}
namespace PDF {
  class PDF_Base;
  class ISR_Handler;
}

namespace CFPSHOWER {
  struct FlavourTriplet {
    std::vector<ATOOLS::Flavour> m_flavs;
    inline FlavourTriplet() { m_flavs.resize(3); }
    inline FlavourTriplet(std::vector<ATOOLS::Flavour> & flavs) {
      m_flavs.resize(3);
      for (size_t i=0;i<3;i++) m_flavs[i] = flavs[i];
    }
    inline bool operator<(const FlavourTriplet &trip) const {
      for (size_t i=0;i<3;i++) {
	if (m_flavs[i]<trip.m_flavs[i]) return true;
      }
      return false;
    }
  };

  class Cluster_Definitions;

  class Shower {
  private:
    double m_t0[2], m_t0min, m_asfactor[2], m_muR2factor, m_muF2factor;
    int    m_kinscheme, m_kfactor, m_cplscheme, m_MEcorrs, m_nmax_em;
    
    MODEL::Model_Base           * p_model;
    PDF::PDF_Base               * p_pdf[2];
    MODEL::Running_AlphaS       * p_as;
    MODEL::Running_AlphaQED     * p_alpha;
    Cluster_Definitions         * p_cluster;
    const ATOOLS::Mass_Selector * p_massselector;
    Configuration               * p_config;
    Splitting                   * p_winner;
    
    std::map<ATOOLS::Flavour, Kernels *> m_kernels[5];
    std::vector<Splitting *>             m_splittings;

    double m_weight, m_weightover;
    
    bool InitializeParameters();
    bool InitializeKernels(MODEL::Model_Base * const model);
    void MakeKernelsFromVertex(MODEL::Single_Vertex * vertex,
			       std::set<FlavourTriplet> & kernel_flavours);
    bool Evolve(Parton * parton);
    bool GenerateTestSplitting(Kernels * kernels,Splitting & split);
    bool PerformSplitting();
    void EstablishSpectators(Parton * parton);
    void AddWeight(const double & t);
  public:
    Shower();
    ~Shower();

    bool Init(MODEL::Model_Base * const,PDF::ISR_Handler * const);
    bool Evolve(Configuration * config);

    void Reset(); 
    inline void SetMassSelector(const ATOOLS::Mass_Selector * ms) {
      p_massselector = ms;
    }
    inline const double & Weight() { return m_weight; }
    
    Cluster_Definitions * const GetClusterDefinitions() const { return p_cluster; }
  };
}
#endif
