#include "Primitive_Observable_Base.H"

#include "MyStrStream.H"
#include "Algebra_Interpreter.H"
#include "Exception.H"
#include <iomanip>

using namespace ATOOLS;

struct TDouble: public Term {
  double m_value;
};// end of struct Double

struct TVec4D: public Term {
  Vec4D m_value;
  TVec4D(const Vec4D &value): m_value(value) {}
};// end of struct Vec4D

namespace ANALYSIS {

  class Two_Particle_Modifier_Base: public Primitive_Observable_Base,
				    public Tag_Replacer {  
  protected:

    std::string m_crit, m_outlist;

    ATOOLS::Flavour m_flav[2];
    size_t          m_item[2];

    ATOOLS::Algebra_Interpreter m_interpreter;

    std::string   ReplaceTags(std::string &expr) const;    
    ATOOLS::Term *ReplaceTags(ATOOLS::Term *term) const;        

  public:

    Two_Particle_Modifier_Base
    (const ATOOLS::Flavour flav[2],const size_t item[2],
     const std::string &crit,
     const std::string &inlist,const std::string &outlist);
    
    void Evaluate(const ATOOLS::Particle_List &particlelist,
		  double weight=1.,int ncount=1);
    
    void EndEvaluation(double scale);

    virtual bool Modify(Particle *&p1,Particle *&p2) const = 0;

  };// end of class Two_Particle_Modifier_Base

  class Two_Particle_Swap: public Two_Particle_Modifier_Base {  
  public:

    Two_Particle_Swap(const ATOOLS::Flavour flav[2],const size_t item[2],
		      const std::string &crit,
		      const std::string &inlist,const std::string &outlist);
    
    bool Modify(Particle *&p1,Particle *&p2) const;

    Primitive_Observable_Base *Copy() const;
    
  };// end of class Two_Particle_Swap

}// end of namespace ANALYSIS

using namespace ANALYSIS;

template <class Class>
Primitive_Observable_Base *const 
GetTwoParticleModifier(const Argument_Matrix &parameters) 
{									
  if (parameters.size()<1) return NULL;
  if (parameters.size()==1) {
    if (parameters[0].size()<7) return NULL;
    size_t item[2];
    ATOOLS::Flavour flav[2];
    for (size_t i(0);i<2;++i) {
      int kf=ATOOLS::ToType<int>(parameters[0][2*i]);
      flav[i]=ATOOLS::Flavour((ATOOLS::kf::code)abs(kf));
      if (kf<0) flav[i]=flav[i].Bar();
      item[i]=ATOOLS::ToType<size_t>(parameters[0][2*i+1]);
    }
    return new Class(flav,item,
		     parameters[0][4],parameters[0][5],parameters[0][6]);
  }
  return NULL;
}									

#define DEFINE_TWO_MODIFIER_GETTER_METHOD(CLASS,NAME)		\
  Primitive_Observable_Base *					\
  NAME::operator()(const Argument_Matrix &parameters) const		\
  { return GetTwoParticleModifier<CLASS>(parameters); }

#define DEFINE_TWO_MODIFIER_PRINT_METHOD(NAME)		\
  void NAME::PrintInfo(std::ostream &str,const size_t width) const	\
  { str<<"flav1 item1 flav2 item2 crit inlist outlist"; }

#define DEFINE_TWO_MODIFIER_GETTER(CLASS,NAME,TAG)		\
  DECLARE_GETTER(NAME,TAG,Primitive_Observable_Base,Argument_Matrix);	\
  DEFINE_TWO_MODIFIER_GETTER_METHOD(CLASS,NAME)		\
  DEFINE_TWO_MODIFIER_PRINT_METHOD(NAME)

#include "Primitive_Analysis.H"

Two_Particle_Modifier_Base::
Two_Particle_Modifier_Base(const ATOOLS::Flavour flav[2],const size_t item[2],
			   const std::string &crit,const std::string &inlist,
			   const std::string &outlist):
  m_crit(crit),
  m_outlist(outlist)
{
  for (size_t i(0);i<2;++i) {
    m_flav[i]=flav[i];
    m_item[i]=item[i];
  }
  m_splitt_flag = false;
  m_listname=inlist;
  msg_Debugging()<<METHOD<<"(): m_crit = '"<<m_crit<<"' {\n";
  size_t bpos(m_crit.find('@')); 
  while (bpos!=std::string::npos) {
    size_t epos(m_crit.find('@',bpos+1));
    if (epos!=std::string::npos && epos-bpos>1) {
      if (m_crit[epos-1]==']') {
	m_interpreter.AddTag(m_crit.substr(bpos,epos-bpos+1),"(1.0,0.0,0.0,1.0)");
	msg_Debugging()<<"  adding vector tag '"
		       <<m_crit.substr(bpos+1,epos-bpos-1)<<"'\n";
      }
      else {
	m_interpreter.AddTag(m_crit.substr(bpos,epos-bpos+1),"1");
	msg_Debugging()<<"  adding double tag '"
		       <<m_crit.substr(bpos+1,epos-bpos-1)<<"'\n";
      }
    }
    bpos=m_crit.find('@',++epos);
  }
  m_interpreter.SetTagReplacer(this);
  m_interpreter.Interprete(m_crit);
  msg_Debugging()<<"}\n";
}

void Two_Particle_Modifier_Base::Evaluate
(const ATOOLS::Particle_List &inlist,double weight,int ncount)
{
  ATOOLS::Particle_List *outlist = new ATOOLS::Particle_List();
  p_ana->AddParticleList(m_outlist,outlist);
  int no(-1);
  size_t pos[2]={std::string::npos,std::string::npos};
  for (size_t k(0);k<2;++k) {
    no=-1;
    for (size_t i(0);i<inlist.size();++i) {
      if (inlist[i]->Flav()==m_flav[k] || 
	  m_flav[k].Kfcode()==ATOOLS::kf::none) {
	++no;
	if (no==(int)m_item[k]) {
	  pos[k]=i;
	  break;
	}
      }
    }
  }
  if (pos[0]==std::string::npos || pos[1]==std::string::npos) return;
  if (((TDouble*)m_interpreter.Calculate())->m_value!=0.0) {
    outlist->resize(inlist.size());
    for (size_t i=0;i<inlist.size();++i) 
      (*outlist)[i] = new ATOOLS::Particle(*inlist[i]);
    Modify((*outlist)[pos[0]],(*outlist)[pos[1]]);
  }
}

void Two_Particle_Modifier_Base::EndEvaluation(double scale)
{
}

std::string Two_Particle_Modifier_Base::ReplaceTags(std::string &expr) const
{
  return m_interpreter.ReplaceTags(expr);
}

Term *Two_Particle_Modifier_Base::ReplaceTags(Term *term) const
{
  std::string tag(term->m_tag.substr(1,term->m_tag.length()-2));
  Blob_Data_Base *data((*p_ana)[tag]);
  if (data==NULL) THROW(critical_error,"Data '"+tag+"' not found.");
  if (term->m_tag[term->m_tag.length()-1]==']') 
    ((TVec4D*)term)->m_value=data->Get<Vec4D>();
  else ((TDouble*)term)->m_value=data->Get<double>();
  return term;
}

DEFINE_TWO_MODIFIER_GETTER(Two_Particle_Swap,
			   Two_Particle_Swap_Getter,"TwoSwap")
  
Two_Particle_Swap::
Two_Particle_Swap(const ATOOLS::Flavour flav[2],const size_t item[2],
		  const std::string &crit,
		  const std::string &inlist,const std::string &outlist):
  Two_Particle_Modifier_Base(flav,item,crit,inlist,outlist) {}

bool Two_Particle_Swap::Modify(Particle *&p1,Particle *&p2) const
{
  std::swap<Particle*>(p2,p1);
  return true;
}

Primitive_Observable_Base *Two_Particle_Swap::Copy() const
{
  return new Two_Particle_Swap(m_flav,m_item,m_crit,m_listname,m_outlist);
}

