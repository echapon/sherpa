#include "QCD_Processes.H"
#include "Single_XS.H"
#include "XS_Selector.H"
#include "FSR_Channel.H"

#include "ISR_Handler.H"
#include "Running_AlphaS.H"
#include "Run_Parameter.H"
#include "XS_Selector.H"
#include "Phase_Space_Handler.H"

#include "MathTools.H"

using namespace EXTRAXS;
using namespace PHASIC;
using namespace MODEL;
using namespace ATOOLS;


QCD_Processes::QCD_Processes(PDF::ISR_Handler * _isr,BEAM::Beam_Spectra_Handler * _beam,
			     ATOOLS::Flavour * _fl,ATOOLS::Selector_Data * _seldata,
			     PHASIC::scl::scheme _scalescheme,int _kfactorscheme,bool fillmodes) : 
  XS_Group(2,2,_fl,_scalescheme,_kfactorscheme,_beam,_isr,_seldata)
{
  SetFSRInterface(NULL);
  SetFSRMode(0);
  m_name=std::string("parton parton -> parton parton");
  aS=(*as)(sqr(rpa.gen.Ecms()));
  p_flavours[0]=p_flavours[1]=p_flavours[2]=p_flavours[3]=ATOOLS::Flavour(ATOOLS::kf::jet);
  if (fillmodes) FillMode(All);
}

void QCD_Processes::FillMode(Mode mode) 
{
  XS_Group *group(NULL);
  p_xsselector->SetOffShell(p_isrhandler->KMROn());
  switch (mode) {
  case All:
  case gggg:
    group = new XS_Group(2,2,p_flavours);
    group->SetName(std::string(" gg -> gg"));
    p_flavours[0] = p_flavours[1] = p_flavours[2] = p_flavours[3] = ATOOLS::Flavour(ATOOLS::kf::gluon);
    group->Add(p_xsselector->GetXS(2,2,p_flavours));
    Add(group);
    if (mode==gggg) break;
  case qqbgg:
    group   = new XS_Group(2,2,p_flavours);
    group->SetName(std::string(" qqb -> gg"));
    p_flavours[2] = p_flavours[3] = Flavour(kf::gluon);
    for (int i=1;i<6;i++) {
      p_flavours[0] = ATOOLS::Flavour(ATOOLS::kf::code(i));
      p_flavours[1] = p_flavours[0].Bar();
      group->Add(p_xsselector->GetXS(2,2,p_flavours));
    }
    Add(group);
    if (mode==qqbgg) break;
  case ggqqb:
    group   = new XS_Group(2,2,p_flavours);
    group->SetName(std::string(" gg -> qqb"));
    p_flavours[0] = p_flavours[1] = Flavour(kf::gluon);
    for (int i=1;i<6;i++) {
      p_flavours[2] = ATOOLS::Flavour(ATOOLS::kf::code(i));
      p_flavours[3] = p_flavours[2].Bar();
      group->Add(p_xsselector->GetXS(2,2,p_flavours));
    }
    Add(group);
    if (mode==ggqqb) break;
  case qgqg:
    group = new XS_Group(2,2,p_flavours);
    group->SetName(std::string(" qg -> qg "));
    p_flavours[0] = p_flavours[2] = Flavour(kf::gluon);
    for (int i=1;i<6;i++) {
      p_flavours[1] = p_flavours[3] = ATOOLS::Flavour(ATOOLS::kf::code(i));
      group->Add(p_xsselector->GetXS(2,2,p_flavours));
    }
    Add(group);
    if (mode==qgqg) break;
  case q1q2q1q2:
    group = new XS_Group(2,2,p_flavours);
    group->SetName(std::string(" q1q2 -> q1q2 "));
    for (int i=1;i<5;i++) {
      p_flavours[0] = p_flavours[2] = ATOOLS::Flavour(ATOOLS::kf::code(i));
      for (int j=i+1;j<6;j++) {
	p_flavours[1] = p_flavours[3] = ATOOLS::Flavour(ATOOLS::kf::code(j));
	group->Add(p_xsselector->GetXS(2,2,p_flavours));
      }
    }
  case q1q2bq1q2b:
    if (mode==q1q2bq1q2b) group = new XS_Group(2,2,p_flavours);
    group->SetName(std::string(" q1q2b -> q1q2b "));
    for (int i=1;i<5;i++) {
      p_flavours[0] = p_flavours[2] = ATOOLS::Flavour(ATOOLS::kf::code(i));
      for (int j=i+1;j<6;j++) {
	p_flavours[1] = p_flavours[3] = ATOOLS::Flavour(ATOOLS::kf::code(j)).Bar();
	group->Add(p_xsselector->GetXS(2,2,p_flavours));
      }
    }
    Add(group);
    if (mode==q1q2bq1q2b) break;
    if (mode==q1q2q1q2) break;
  case q1q1q1q1:
    group = new XS_Group(2,2,p_flavours);
    group->SetName(std::string(" q1q1 -> q1q1 "));
    for (int i=1;i<6;i++) {
      p_flavours[0] = p_flavours[1] = p_flavours[2] = p_flavours[3] = ATOOLS::Flavour(ATOOLS::kf::code(i));
      group->Add(p_xsselector->GetXS(2,2,p_flavours));
    }
    Add(group);
    if (mode==q1q1q1q1) break;
  case q1q1bq1q1b:
    group = new XS_Group(2,2,p_flavours);
    group->SetName(std::string(" q1q1b -> q1q1b "));
    for (int i=1;i<6;i++) {
      p_flavours[0] = p_flavours[2] = ATOOLS::Flavour(ATOOLS::kf::code(i));
      p_flavours[1] = p_flavours[3] = p_flavours[0].Bar();
      group->Add(p_xsselector->GetXS(2,2,p_flavours));
    }
    Add(group);
    if (mode==q1q1bq1q1b) break;
  case q1q1bq2q2b:
    group = new XS_Group(2,2,p_flavours);
    group->SetName(std::string(" q1q1b -> q2q2b "));
    for (int i=1;i<5;i++) {
      p_flavours[0] = ATOOLS::Flavour(ATOOLS::kf::code(i));
      p_flavours[1] = p_flavours[0].Bar();
      for (int j=i+1;j<6;j++) {
	p_flavours[2] = ATOOLS::Flavour(ATOOLS::kf::code(j)).Bar();
	p_flavours[3] = p_flavours[2].Bar();
	group->Add(p_xsselector->GetXS(2,2,p_flavours));
      }
    }
    Add(group);
    if (mode==q1q1bq2q2b) break;
    break;
  case Unknown:
    ATOOLS::msg.Error()<<"QCD_Processes::FillMode("<<mode<<"): No mode specified! Abort."<<std::endl;
  case None:
    break;
  }
}

void QCD_Processes::CreateFSRChannels() 
{
  if ((m_fsrmode==0)||(p_fsrinterface==NULL)) {
    p_pshandler->FSRIntegrator()->DropAllChannels();
    p_pshandler->FSRIntegrator()->Add(new S1Channel(2,2,p_flavours,Flavour(kf::photon)));
    p_pshandler->FSRIntegrator()->Add(new T1Channel(2,2,p_flavours));
    p_pshandler->FSRIntegrator()->Add(new U1Channel(2,2,p_flavours));
    m_fsrmode=1;
  }
  else {
    if (m_fsrmode==2) {
      p_pshandler->FSRIntegrator()->DropAllChannels();
      p_pshandler->FSRIntegrator()->Add(p_fsrinterface);
      m_fsrmode=1;
    }
  }
}

void QCD_Processes::InitIntegrators() 
{
  if (p_isrhandler->On()) {
    p_isrhandler->SetPartonMasses(p_flavours);
    for (unsigned int i=0;i<m_xsecs.size();i++) m_xsecs[i]->SetISR(p_isrhandler);
    p_pshandler->ISRIntegrator()->DropAllChannels();
    if (p_pshandler->KMRZIntegrator()!=NULL) p_pshandler->KMRZIntegrator()->DropAllChannels();
    if (p_pshandler->KMRKPIntegrator()!=NULL) p_pshandler->KMRKPIntegrator()->DropAllChannels();
  }
  p_pshandler->CreateIntegrators();
  p_pshandler->ISRIntegrator()->Reset();
  if (p_isrhandler->KMROn()) {
    p_pshandler->KMRZIntegrator()->Reset();
    p_pshandler->KMRKPIntegrator()->Reset();
  }
  p_pshandler->FSRIntegrator()->Reset();
}
      
void QCD_Processes::SetFSRMode(int _m_fsrmode) 
{ m_fsrmode=_m_fsrmode; }

void QCD_Processes::SetFSRInterface(PHASIC::Channel_Interface *_p_fsrinterface)
{ p_fsrinterface=_p_fsrinterface; }

int QCD_Processes::FSRMode()      
{ return m_fsrmode; }

PHASIC::Channel_Interface *QCD_Processes::FSRInterface() 
{ return p_fsrinterface; }
