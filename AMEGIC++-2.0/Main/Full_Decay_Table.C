#include "Full_Decay_Table.H"

using namespace AMEGIC;
using namespace ATOOLS;
using namespace std;

Full_Decay_Channel::Full_Decay_Channel(Decay_Channel * _dec) :
 p_dec(_dec), p_proc(NULL) { }


Full_Decay_Channel::Full_Decay_Channel(const Flavour _fl) :
  p_proc(NULL)
{
  p_dec = new Decay_Channel(_fl);
}

void Full_Decay_Channel::AddDecayProduct(const Flavour & _fl) 
{
  p_dec->AddDecayProduct(_fl);
}

void Full_Decay_Channel::Output()
{
  FlavourSet decs = p_dec->GetDecayProducts();
  msg_Out()<<"  "<<(p_dec->GetDecaying())<<" -> ";
  for (FlSetIter fl=decs.begin();fl!=decs.end();++fl) msg_Out()<<(*fl)<<" ";
  msg_Out()<<" : "<<p_dec->Width()<<" GeV.";
  if (p_proc) msg_Out()<<"  : "<<p_proc->Name();
  msg_Out()<<endl;
}
 

bool Full_Decay_Channel::CreateDecay()
{
  FlavourSet decs = p_dec->GetDecayProducts();
  Flavour * flavs = new Flavour[1+decs.size()];
  flavs[0]    = (p_dec->GetDecaying());
  int i       = 0;
  double mass = 0.;
  for (FlSetIter fl=decs.begin();fl!=decs.end();++fl) {
    i++;
    flavs[i] = (*fl);
    mass    += (*fl).Mass();
  }
  if (mass>flavs[0].Mass()) {
    p_dec->SetWidth(0.);
    return 0;
  }
  if (decs.size()==2) p_proc = new Single_Process(1,decs.size(),flavs);
                 else p_proc = new Single_Process(1,decs.size(),flavs,NULL,NULL,NULL,2);
  p_dec->SetProcessName(p_proc->Name());
  return 1;
}

bool Full_Decay_Channel::CalculateWidth() 
{
  return true;
}


void Full_Decay_Channel::SetWidth(double _w ) 
{
  if (_w<0.) p_dec->SetWidth(p_proc->TotalXS()); 
  else p_dec->SetWidth(_w);
  if (msg_LevelIsInfo()) Output();
}

//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

Full_Decay_Table::Full_Decay_Table(const Flavour _fl,bool _overwrite) :
  m_width(0.), m_flin(_fl), m_isevaluated(0), m_overwrite(_overwrite) { }


void Full_Decay_Table::AddDecayChannel(Decay_Channel * _dc)
{
  if (m_isevaluated) return;
  m_channels.push_back(new Full_Decay_Channel(_dc));
  m_width += _dc->Width();
}
void Full_Decay_Table::AddDecayChannel(Full_Decay_Channel * _dc)
{
  if (m_isevaluated) return;
  m_channels.push_back(_dc);
  m_width += _dc->Width();
}




bool Full_Decay_Table::InitAllDecays(Interaction_Model_Base * _model,Topology * _top)
{
  if (m_isevaluated) return 1;
  Vec4D * moms = NULL;
  vector<Process_Base *> links,errs;
  int totalsize = 0;
  int procs     = 0;
  int current_atom = 0;

  bool okay = 1;
  for (size_t i=0;i<m_decaymodes.size();i++) {
    msg_Tracking()<<"============================================================"<<endl;
    if (moms) { delete [] moms; moms = NULL; }
    links.clear();
    okay = okay && m_decaymodes[i]->InitAmplitude(_model,_top,moms,links,errs,totalsize,procs,current_atom);
    for (size_t j=0;j<links.size();j++) {
      msg_Tracking()<<"Set up integrator of "<<j<<" : "<<links[j]->Name()<<endl;
      if (!(links[j]->SetUpIntegrator())) okay = 0;
    }
    if (okay) {
      msg_Tracking()<<"Set Selector of "<<i<<" : "<<(*m_decaymodes[i])[0]->Name()<<endl;
      m_decaymodes[i]->SetSelector((*m_decaymodes[i])[0]->Selector());
      okay = okay && m_decaymodes[i]->SetUpIntegrator();
    }
  }
  return okay;
}

void Full_Decay_Table::ArrangeDecays()
{
  if (m_isevaluated) return;
  Process_Group * group;
  Process_Base  * proc;
  size_t             nout;
//   Flavour       * flavs;
  bool newgroup = 1;
  bool alreadyin,match,initgroup;
  while (newgroup) {
    newgroup = 0;
    for (size_t i=0;i<m_channels.size();i++) {
      proc     = m_channels[i]->GetProcessBase();
      nout     = proc->NOut();
      initgroup = 1;
      if (m_decaymodes.size()>0) {
	for (size_t j=0;j<m_decaymodes.size();j++) {
	  alreadyin = 0;
	  for (size_t k=0;k<m_decaymodes[j]->Size();k++) {
	    if (proc->Name()==(*m_decaymodes[j])[k]->Name()) {
	      alreadyin = 1;
	      break;
	    } 
	  }
	  if (alreadyin) { initgroup = 0; break; }
	  if (m_decaymodes[j]->NOut()==nout) {
	    match = 1;
	    for (size_t k=0;k<m_decaymodes[j]->NOut();k++) {
	      if ((((*m_decaymodes[j])[0]->Flavours())[k+1]).Mass()!=((proc->Flavours())[k+1]).Mass()) {
		match = 0;
		break;
	      }
	    }
	    if (match==1) {
	      m_decaymodes[j]->Add(proc);
	      initgroup = 0;
	      break;
	    }
	  }
	}
      }
      if (initgroup==1) {
	newgroup = 1;
// 	flavs = proc->Flavours();
	group = new Process_Group();
	group->SetName("Decay for : "+proc->Flavours()[0].TexName());
	group->Add(proc);
	group->SetAtoms(0);
	m_decaymodes.push_back(group);
	break;
      }
    }
  }
}



void Full_Decay_Table::CalculateWidths()
{
  if (m_isevaluated) return;
  for (size_t i=0;i<m_decaymodes.size();i++) {
    msg_Tracking()<<"Full_Decay_Table::CalculateWidths for "
		  <<m_decaymodes[i]->Size()<<" decay(s)."<<endl;
    m_decaymodes[i]->CalculateTotalXSec(string(""));
  }
  for (size_t i=0;i<m_channels.size();i++) {
    m_channels[i]->SetWidth();
    m_width += m_channels[i]->Width();
  }
  if (m_overwrite) m_flin.SetWidth(m_width);
  else {
    for (size_t i=0;i<m_channels.size();i++) 
      m_channels[i]->SetWidth(m_channels[i]->Width()/m_width*m_flin.Width());
  }
  m_isevaluated = 1;
}

Decay_Channel * Full_Decay_Table::GetChannel(int _ch) 
{
  if (_ch<0 || _ch>=(int)m_channels.size()) {
    msg_Error()<<"Error in Full_Decay_Table::Channel("<<_ch<<")."<<endl
	       <<"    Out of bounds : 0 ... "<<m_channels.size()-1<<"."<<endl
	       <<"    Return NULL."<<endl;
    return new Decay_Channel();
  }
  return m_channels[_ch]->GetDecayChannel();
}

Full_Decay_Channel * Full_Decay_Table::GetFullChannel(int _ch) 
{
  if (_ch<0 || _ch>=(int)m_channels.size()) {
    msg_Error()<<"Error in Full_Decay_Table::GetFullChannel("<<_ch<<")."<<endl
	       <<"    Out of bounds : 0 ... "<<m_channels.size()-1<<"."<<endl
	       <<"    Return NULL."<<endl;
    return NULL;
  }
  return m_channels[_ch];
}

void Full_Decay_Table::Output() {
  msg_Out()<<"Decay table for : "<<m_flin<<", total width : "<<m_width<<" GeV ("
	   <<m_flin.Width()<<" GeV)."<<endl
	   <<"----------------------------------------------------------------"<<endl;
  for (size_t i=0;i<m_channels.size();i++) m_channels[i]->Output();
  msg_Out()<<"----------------------------------------------------------------"<<endl;
}





