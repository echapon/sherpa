#include "Fragmentation_Handler.H"

#include "CXXFLAGS.H"
#include "Data_Reader.H"
#include "Run_Parameter.H"
#include "Shell_Tools.H"
#include "Return_Value.H"

#ifdef PROFILE__all
#define PROFILE__Fragmentation_Handler
#endif
#ifdef PROFILE__Fragmentation_Handler
#include "prof.hh" 
#else
#define PROFILE_HERE
#endif

using namespace SHERPA;
using namespace ATOOLS;
using namespace std;
#ifdef USING__Ahadic
using namespace AHADIC;
#include "Hadron_Init.H"
#else
#error Ahadic must be enabled for filling the hadron tables.
#endif

Fragmentation_Handler::Fragmentation_Handler(string _dir,string _file):
  m_dir(_dir), m_file(_file), m_mode(0)
#ifdef USING__Ahadic
  ,p_ahadic(NULL)
#endif
#ifdef USING__PYTHIA
  ,p_lund(NULL)
#endif
{
  Data_Reader dr(" ",";","!","=");
  dr.AddWordSeparator("\t");
  dr.AddIgnore("[");
  dr.AddIgnore("]");
  dr.SetInputPath(m_dir);
  dr.SetInputFile(m_file);
  m_fragmentationmodel=dr.GetValue<string>("FRAGMENTATION",string("Ahadic"));
  if (m_fragmentationmodel==string("Lund")) {
#ifndef USING__PYTHIA
    THROW(fatal_error, "Fragmentation/decay interface to Pythia has not been "+
          string("enabled during compilation (./configure --enable-pythia)."));
#else
    m_sfile=dr.GetValue<string>("LUND_FILE",string("Lund.dat"));
    Hadron_Init init;
    init.Init();
    init.OverWriteProperties(dr);
    ATOOLS::OutputHadrons(msg->Tracking());
    p_lund = new Lund_Interface(m_dir,m_sfile,true);
    m_mode=1;
    exh->AddTerminatorObject(this);
    // hack for particle initialization, because we don't want to replicate
    // this method in the obsolete Lund Interface.
    return;
#endif
  }
#ifdef USING__Ahadic
  else if (m_fragmentationmodel==string("Ahadic")) {
    m_sfile=dr.GetValue<string>("AHADIC_FILE",m_file);
    Hadron_Init init;
    init.Init();
    init.OverWriteProperties(dr);
    ATOOLS::OutputHadrons(msg->Tracking());
    p_ahadic = new AHADIC::Ahadic(m_dir,m_sfile,true);
    m_mode=2;
    exh->AddTerminatorObject(this);
    return;
  }
#endif
  else if (m_fragmentationmodel==string("Off")) return;
  THROW(critical_error,"Fragmentation model not implemented.");
}
   
Fragmentation_Handler::~Fragmentation_Handler() 
{
#ifdef USING__PYTHIA
  if (p_lund!=NULL)   { delete p_lund;   p_lund   = NULL;   }
#endif
#ifdef USING__Ahadic
  if (p_ahadic!=NULL) { delete p_ahadic; p_ahadic = NULL;   }
#endif
  exh->RemoveTerminatorObject(this);
}

void Fragmentation_Handler::PrepareTerminate() 
{
  std::string path(rpa.gen.Variable("SHERPA_STATUS_PATH"));
  if (path=="") return;
  CopyFile(m_dir+"/"+m_sfile,path+"/"+m_sfile);
}

Return_Value::code Fragmentation_Handler::PerformFragmentation(Blob_List *bloblist,
							       Particle_List *particlelist) 
{
  PROFILE_HERE;
  if (m_mode==0 || bloblist->size()==0) return Return_Value::Nothing;
  switch (int(ExtractSinglets(bloblist))) {
    case int(Return_Value::Success) : break;
    case int(Return_Value::Nothing) : return Return_Value::Nothing;
    case int(Return_Value::Error)   : return Return_Value::Error;
    default :
      msg_Error()<<"ERROR in "<<METHOD<<":"<<std::endl
		 <<"   ExtractSinglets yields unknown return value."<<std::endl
		 <<"   Return 'Retry_Event' and hope for the best."<<std::endl;
      return Return_Value::Retry_Event;
  }
  switch (m_mode) {
#ifdef USING__PYTHIA
    case 1  : return p_lund->Hadronize(bloblist);
#endif
#ifdef USING__Ahadic
    case 2  : return p_ahadic->Hadronize(bloblist);
#endif
    default : 
      msg_Error()<<"ERROR in "<<METHOD<<":"<<std::endl
		 <<"   Unknown hadronization model in mode = "<<m_mode<<"."<<std::endl
		 <<"   Abort the run."<<std::endl;
      THROW(critical_error,"Fragmentation model not implemented.");
  }
}

Return_Value::code Fragmentation_Handler::ExtractSinglets(Blob_List * bloblist)
{
  Particle  * part(NULL);
  Blob      * blob(NULL);
  std::vector<Part_List*> plists;
  plists.push_back(new Part_List);
  for (Blob_List::iterator blit=bloblist->begin();blit!=bloblist->end();++blit) {
    if ((*blit)->Has(blob_status::needs_hadronization)) {
      // If not coming from hadron decays, fill default plists[0].
      // If from hadron decays, create separate plist for each blob
      // such that there is a one-to-one correspondence between
      // fragmentation outcome and hadron decay. This is needed for setting
      // the correct vertex position, and to reject exclusive final states
      Part_List* plist(plists[0]);
      Blob* upstream_blob=(*blit)->UpstreamBlob();
      if (upstream_blob && upstream_blob->Type()==btp::Hadron_Decay) {
        plist=new Part_List;
        plists.push_back(plist);
      }

      std::vector<Particle*> taus;
      for (int i=0;i<(*blit)->NOutP();i++) {
	part = (*blit)->OutParticle(i); 
	if (part->Status()==part_status::active) {
	  if (part->GetFlow(1)!=0 || part->GetFlow(2)!=0) {
	    plist->push_back(part);
	    part->SetStatus(part_status::fragmented);
	  }
	  else if (part->Flav()==Flavour(kf_tau) ||
		   part->Flav()==Flavour(kf_tau).Bar()) {
            taus.push_back(part);
	  }
	}
      }
      if (taus.size()>0) {
        blob = new Blob();
        blob->SetId();
        blob->SetType(btp::Fragmentation);
        blob->SetStatus(blob_status::needs_hadrondecays);
        for (size_t i=0;i<taus.size();++i) {
          blob->AddToInParticles(taus[i]);
          taus[i]->SetStatus(part_status::decayed);
          blob->AddToOutParticles(new Particle((*taus[i])));
          blob->GetOutParticles().back()->SetStatus(part_status::active);
        }
        bloblist->push_back(blob);
      }
      (*blit)->UnsetStatus(blob_status::needs_hadronization);
    }
  }
  if (plists[0]->empty() && plists.size()<2) {
    msg_Debugging()<<"WARNING in Lund_Interface::PrepareFragmentationBlob:"<<endl
		   <<"   No coloured particle found leaving shower blobs."<<endl;
    delete plists[0];
    return Return_Value::Nothing;
  }


  Return_Value::code ret(Return_Value::Success);
  for (size_t i=0; i<plists.size(); ++i) {
  if (plists[i]->empty()) continue;
  Part_List* plist=plists[i];
  int  col1, col2;
  bool hit1, hit2;
  Part_List * pli(NULL);
  vector<Part_List *> partlists; 
  do {
    hit1 = false;
    for (Part_Iterator pit=plist->begin();pit!=plist->end();++pit) {
      col1 = (*pit)->GetFlow(1);
      col2 = (*pit)->GetFlow(2);
      if (col1!=0 && col2==0) {
	hit1 = true;
	pli  = new Part_List;
	pli->push_back((*pit));
	pit  = plist->erase(pit);
	partlists.push_back(pli);
	do {
	  hit2 = false;
	  for (Part_Iterator pit1=plist->begin();pit1!=plist->end();++pit1) {
	    if ((int)((*pit1)->GetFlow(2))==col1) {
	      col1 = (*pit1)->GetFlow(1);
	      pli->push_back((*pit1));
	      pit1 = plist->erase(pit1);
	      hit2 = true;
	      break;
	    }
	  }
	} while (hit2 && col1!=0);
      }
      if (hit1) break;
    }
    if (!hit1) {
      for (Part_Iterator pit=plist->begin();pit!=plist->end();++pit) {
	col1 = (*pit)->GetFlow(1);
	col2 = (*pit)->GetFlow(2);
	if (col1!=0 && col2!=0) {
	  hit1 = true;
	  pli  = new Part_List;
	  pli->push_back((*pit));
	  pit  = plist->erase(pit);
	  partlists.push_back(pli);
	  do {
	    hit2 = false;
	    for (Part_Iterator pit1=plist->begin();pit1!=plist->end();++pit1) {
	      if ((int)((*pit1)->GetFlow(2))==col1) {
		col1 = (*pit1)->GetFlow(1);
		pli->push_back((*pit1));
		pit1 = plist->erase(pit1);
		hit2 = true;
		break;
	      }
	    }
	  } while (hit2 && col1!=col2);
	}
	if (hit1) break;
      }
    }
  } while(plist->size()>0);

  if (plist->empty()) {
    blob = new Blob();
    blob->SetId();
    blob->SetType(btp::Fragmentation);
    blob->SetStatus(blob_status::needs_hadronization);
    bloblist->push_back(blob);
    for (vector<Part_List *>::iterator pliter=partlists.begin();
	 pliter!=partlists.end();pliter++) {
      while (!(*pliter)->empty()) {
	blob->AddToInParticles((*pliter)->front());
	(*pliter)->pop_front();
      }
    }
    
    for(size_t i=0;i<partlists.size();i++) {
      delete partlists[i];
    }
    delete plist;
    ret=Return_Value::Success;
  }
  else {
    for(size_t i=0;i<partlists.size();i++) {
      delete partlists[i];
    }
    delete plist;
    ret=Return_Value::Error;
    break;
  }
  }
  return ret;
}

