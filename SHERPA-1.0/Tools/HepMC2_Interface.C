#include "HepMC2_Interface.H"

#include "Blob_List.H"
#include "Particle.H"
#include "Vector.H"
#include "Run_Parameter.H"

#include "HepMC/GenEvent.h"
#include "HepMC/GenVertex.h"
#include "HepMC/GenParticle.h"
#include "HepMC/SimpleVector.h"

using namespace SHERPA;

HepMC2_Interface::HepMC2_Interface():
  p_event(new HepMC::GenEvent()), m_converted(false)
{
}

HepMC2_Interface::~HepMC2_Interface()
{
  delete p_event;
}

void HepMC2_Interface::PrintEvent(std::ostream& ostr)
{
  // probably need to use HepMC::IO_Ascii::write_event( const GenEvent* evt )
  // but that doesn't support writing to a stream :-((
  p_event->print(ostr);
}

bool HepMC2_Interface::Sherpa2HepMC(ATOOLS::Blob_List *const blobs)
{
  if(m_converted) return true;
  if (blobs->empty()) {
    msg_Error()<<"Error in HepMC2_Interface::Sherpa2HepMC(Blob_List)."<<std::endl
		       <<"   Empty list - nothing to translate into HepMC standard."<<std::endl
		       <<"   Continue run ... ."<<std::endl;
    return true;
  }
  if (p_event!=NULL) delete p_event;
  p_event = new HepMC::GenEvent();
  p_event->set_event_number(ATOOLS::rpa.gen.NumberOfDicedEvents());
  m_blob2genvertex.clear();
  m_particle2genparticle.clear();
  HepMC::GenVertex * vertex;
  for (ATOOLS::Blob_List::iterator blit=blobs->begin();blit!=blobs->end();++blit) {
    if (Sherpa2HepMC(*(blit),vertex)) {
      p_event->add_vertex(vertex);
      if ((*blit)->Type()==ATOOLS::btp::Signal_Process)
        p_event->set_signal_process_vertex(vertex);
    }
  }
  m_converted=true;
  return true;
}

bool HepMC2_Interface::Sherpa2HepMC(ATOOLS::Blob * blob, HepMC::GenVertex *& vertex)
{
  if (blob->Type()==ATOOLS::btp::Bunch) return false;
  int count = m_blob2genvertex.count(blob);
  if (count>0) {
    vertex = m_blob2genvertex[blob];
    return true;
  }
  else {
    ATOOLS::Vec4D pos = blob->Position();
    HepMC::FourVector position(pos[1],pos[2],pos[3],pos[0]);
    vertex = new HepMC::GenVertex(position,blob->Id());
    vertex->weights().push_back(1.);
  }

  bool okay = 1;
  HepMC::GenParticle * _particle;
  for (int i=0;i<blob->NInP();i++) {
    if (Sherpa2HepMC(blob->InParticle(i),_particle)) {
      vertex->add_particle_in(_particle);
    }
    else okay = 0;
  }
  for (int i=0;i<blob->NOutP();i++) {
    if (Sherpa2HepMC(blob->OutParticle(i),_particle)) {
      vertex->add_particle_out(_particle);
    }
    else okay = 0;
  }
  m_blob2genvertex.insert(std::make_pair(blob,vertex));
  if (!okay) {
    msg_Error()<<"Error in HepMC2_Interface::Sherpa2HepMC(Blob,Vertex)."<<std::endl
		       <<"   Continue event generation with new event."<<std::endl;
  }
  if (msg_LevelIsDebugging()) {
    ATOOLS::Vec4D check = blob->CheckMomentumConservation();
    double test         = ATOOLS::Vec3D(check).Abs();
    if (ATOOLS::dabs(1.-vertex->check_momentum_conservation()/test)>1.e-5 &&
	ATOOLS::dabs(test)>1.e-5)
      {
	msg_Error()<<"ERROR in "<<METHOD<<std::endl
			   <<"   Momentum not conserved. Continue."<<std::endl
			   <<"ERROR in Blob -> Vertex : "<<vertex->check_momentum_conservation()
			   <<" <- "<<test<<" "<<check
			   <<std::endl<<(*blob)<<std::endl;
	vertex->print(std::cout);
	std::cout<<"--------------------------------------------------------"<<std::endl;
      }
  }
  return okay;
}

bool HepMC2_Interface::Sherpa2HepMC(ATOOLS::Particle * parton,HepMC::GenParticle *& particle)
{
  int count = m_particle2genparticle.count(parton);
  if (count>0) {
    particle = m_particle2genparticle[parton];
    return true;
  }

  ATOOLS::Vec4D mom  = parton->Momentum();
  HepMC::FourVector momentum(mom[1],mom[2],mom[3],mom[0]);
  int stat = int(parton->Status());
  if (parton->DecayBlob()!=NULL) stat = 2;
               else if (stat==2) stat=1;
  if (stat==2) {
    if (parton->DecayBlob()->Type()==ATOOLS::btp::Signal_Process ||
	parton->ProductionBlob()->Type()==ATOOLS::btp::Signal_Process) stat = 3;
  }
  particle = new HepMC::GenParticle(momentum,parton->Flav().HepEvt(),stat);
  for (int i=1;i<3;i++) {
    if (parton->GetFlow(i)>0) particle->set_flow(i,parton->GetFlow(i));
  }
  m_particle2genparticle.insert(std::make_pair(parton,particle));
  return true;
}

